# CardMind 架构设计文档

## 1. 整体架构概述

### 1.1 前后端分离架构
- **前端**：Flutter负责UI渲染和网络权限申请
- **后端**：Rust负责核心业务逻辑，包括数据存储、同步、设备组网和通信等
- **通信机制**：前后端通过flutter_rust_bridge进行通信

### 1.2 技术栈

| 分层 | 技术 | 用途 |
|------|------|------|
| 前端 | Flutter | 跨平台UI框架 |
| 通信桥梁 | flutter_rust_bridge | 前后端通信 |
| 后端 | Rust | 核心业务逻辑 |
| CRDT库 | Loro | 分布式数据同步 |
| P2P网络 | libp2p | 设备间通信和服务发现 |
| 数据库ORM | sea-orm | SQLite操作封装 |
| 数据库驱动 | rusqlite | SQLite数据库访问 |
| 存储 | SQLite | 本地数据持久化 |
| ID生成 | UUID v7 | 分布式ID生成 |

## 2. 前后端通信机制

### 2.1 通信流程
1. Flutter端定义API接口和数据模型
2. 通过flutter_rust_bridge_codegen生成Rust和Flutter的通信代码
3. Rust端实现API接口的业务逻辑
4. Flutter端调用生成的API接口
5. flutter_rust_bridge负责数据序列化和跨语言调用

### 2.2 数据序列化
- 使用protobuf或类似机制进行数据序列化
- 自动生成序列化/反序列化代码
- 支持复杂数据类型的跨语言传输

### 2.3 错误处理
- 定义统一的错误码和错误信息格式
- Rust端返回结构化的错误信息
- Flutter端解析错误信息并显示给用户

## 3. 数据同步机制

### 3.1 CRDT同步原理
- 基于Loro的CRDT算法实现无冲突数据同步
- 每个卡片和协作网络对应一个LoroDoc对象
- LoroDoc使用UUID v7作为唯一标识符

### 3.2 数据流向

#### 3.2.1 写操作
1. Flutter端调用写操作API
2. Rust端将数据写入LoroDoc
3. Loro通过subscribe机制自动更新SQLite表
4. 通过libp2p将更新同步到其他设备

#### 3.2.2 读操作
1. Flutter端调用读操作API
2. Rust端直接从SQLite表中读取数据
3. 返回数据给Flutter端

### 3.3 设备发现与连接
- 基于libp2p的mDNS协议实现本地网络设备发现
- 设备直接通过libp2p建立P2P连接
- 无需传统的信令服务器

## 4. 数据库设计

### 4.1 表结构设计

#### 4.1.1 卡片表
| 字段名 | 类型 | 描述 |
|--------|------|------|
| id | TEXT | 卡片唯一标识符（UUID v7） |
| title | TEXT | 卡片标题 |
| content | TEXT | 卡片内容 |
| created_at | INTEGER | 创建时间戳 |
| updated_at | INTEGER | 更新时间戳 |
| loro_doc | BLOB | LoroDoc二进制数据 |

#### 4.1.2 协作网络表
| 字段名 | 类型 | 描述 |
|--------|------|------|
| id | TEXT | 网络唯一标识符（UUID v7） |
| name | TEXT | 网络昵称 |
| password | TEXT | 加密后的网络密码 |
| created_at | INTEGER | 创建时间戳 |
| updated_at | INTEGER | 更新时间戳 |
| loro_doc | BLOB | LoroDoc二进制数据 |

#### 4.1.3 设备表
| 字段名 | 类型 | 描述 |
|--------|------|------|
| id | TEXT | 设备唯一标识符（设备指纹） |
| name | TEXT | 设备昵称 |
| created_at | INTEGER | 创建时间戳 |
| updated_at | INTEGER | 更新时间戳 |

#### 4.1.4 网络设备关联表
| 字段名 | 类型 | 描述 |
|--------|------|------|
| network_id | TEXT | 网络唯一标识符 |
| device_id | TEXT | 设备唯一标识符 |
| joined_at | INTEGER | 加入时间戳 |

#### 4.1.5 卡片网络关联表
| 字段名 | 类型 | 描述 |
|--------|------|------|
| card_id | TEXT | 卡片唯一标识符 |
| network_id | TEXT | 网络唯一标识符 |
| added_at | INTEGER | 添加时间戳 |

#### 4.1.6 常驻网络表
| 字段名 | 类型 | 描述 |
|--------|------|------|
| device_id | TEXT | 设备唯一标识符 |
| network_id | TEXT | 网络唯一标识符 |
| set_at | INTEGER | 设置时间戳 |

## 5. 测试策略

### 5.1 测试分层

#### 5.1.1 单元测试
- **范围**：单个功能模块或函数
- **框架**：Rust测试框架
- **覆盖范围**：≥80%
- **重点测试**：
  - ID生成逻辑
  - 数据验证
  - 核心业务逻辑

#### 5.1.2 集成测试
- **范围**：多个模块协同工作
- **框架**：Rust集成测试框架
- **重点测试**：
  - API接口
  - 数据库操作
  - 前后端通信

#### 5.1.3 功能测试
- **范围**：完整功能流程
- **框架**：Flutter集成测试框架
- **重点测试**：
  - 卡片CRUD操作
  - 网络管理
  - 数据同步

#### 5.1.4 端到端测试
- **范围**：多设备协同工作
- **方法**：使用真实设备或模拟器
- **重点测试**：
  - 多设备同步
  - 网络状态变化
  - 边界情况处理

### 5.2 测试数据管理
- 使用测试专用数据库
- 自动生成测试数据
- 测试前后清理数据

## 6. 部署与构建

### 6.1 构建流程
1. 生成flutter_rust_bridge通信代码
2. 构建Rust核心库
3. 构建Flutter应用
4. 打包生成各平台安装包

### 6.2 依赖管理
- Flutter端使用pub管理依赖
- Rust端使用Cargo管理依赖
- 定期更新依赖版本
- 确保依赖版本兼容性

## 7. 性能优化

### 7.1 读写分离
- 读操作直接访问SQLite
- 写操作通过Loro同步到SQLite
- 减少数据库锁竞争

### 7.2 增量同步
- 使用Loro的增量同步机制
- 仅传输变化的数据
- 减少网络带宽消耗

### 7.3 缓存策略
- 合理使用内存缓存
- 减少数据库访问次数
- 提高响应速度

## 8. 安全设计

### 8.1 数据加密
- 网络密码加密存储
- 设备间通信加密
- 敏感数据保护

### 8.2 身份验证
- 设备指纹识别
- 网络密码验证
- 防止未授权访问

### 8.3 输入验证
- 前后端双重验证
- 防止注入攻击
- 确保数据完整性

## 9. 扩展性设计

### 9.1 模块划分
- 遵循开闭原则
- 模块化设计
- 便于功能扩展

### 9.2 API设计
- 面向接口编程
- 版本化API
- 向后兼容

### 9.3 技术选型
- 选择模块化、可扩展的技术栈
- 支持多种传输协议
- 便于适配新平台