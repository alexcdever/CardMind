# CardMind 架构设计文档

## 1. 整体架构概述

### 1.1 前后端分离架构
- **前端**：Flutter负责UI渲染和网络权限申请
- **后端**：Rust负责核心业务逻辑，包括数据存储、同步、设备组网和通信等
- **通信机制**：前后端通过flutter_rust_bridge进行通信

### 1.2 技术栈

| 分层 | 技术 | 用途 |
|------|------|------|
| 前端 | Flutter | 跨平台UI框架 |
| 通信桥梁 | flutter_rust_bridge | 前后端通信 |
| 后端 | Rust | 核心业务逻辑 |
| CRDT库 | Loro | 分布式数据同步 |
| P2P网络 | libp2p | 设备间通信和服务发现 |
| 数据库ORM | sea-orm | SQLite操作封装 |
| 存储 | SQLite | 元数据持久化 |
| 存储 | Loro文件系统 | CRDT数据持久化 |
| ID生成 | UUID v7 | 分布式ID生成 |

### 1.3 Rust端三层架构

Rust端采用经典的三层架构设计，遵循开闭原则和单一职责原则。

#### 1.3.1 架构层次

```
┌─────────────────────────────────────────────────┐
│                 Flutter 层                      │
│            (UI渲染、用户交互)                    │
└─────────────────────────────────────────────────┘
                      ↓ ↑
           flutter_rust_bridge (FFI)
                      ↓ ↑
┌─────────────────────────────────────────────────┐
│              Controller 层                      │
│      (API暴露、参数验证、错误转换)               │
└─────────────────────────────────────────────────┘
                      ↓ ↑
┌─────────────────────────────────────────────────┐
│               Service 层                        │
│    (业务逻辑、资源管理、CRDT同步、P2P通信)       │
└─────────────────────────────────────────────────┘
                      ↓ ↑
┌─────────────────────────────────────────────────┐
│                 DAO 层                          │
│      (数据持久化、SQLite、Loro文件系统)          │
└─────────────────────────────────────────────────┘
```

#### 1.3.2 Controller 层（API控制层）

**职责**：
- 通过flutter_rust_bridge暴露API给Flutter端
- 遵循开闭原则：对扩展开放，对修改封闭
- 参数验证和格式转换
- 统一错误处理和返回格式

**设计原则**：
- API接口定义清晰，面向接口编程
- 不包含业务逻辑，仅作为调用入口
- 所有API函数使用`pub`关键字暴露
- 使用Result类型统一错误处理

**示例结构**：
```rust
// rust/src/api/card_controller.rs
pub async fn create_card(title: String, content: String) -> Result<Card, ApiError>
pub async fn update_card(id: String, title: String, content: String) -> Result<Card, ApiError>
pub async fn delete_card(id: String) -> Result<(), ApiError>
pub async fn get_cards() -> Result<Vec<Card>, ApiError>
```

#### 1.3.3 Service 层（业务逻辑层）

**职责**：
- 管理业务资源的增删改查（CRUD）
- 实现核心业务逻辑
- 协调DAO层和外部服务（Loro、libp2p）
- 处理CRDT同步和P2P通信
- 实现业务规则（如常驻空间、软删除等）

**设计原则**：
- 每个业务模块对应一个Service（如CardService、CollaborationSpaceService）
- Service之间可以相互调用，处理复杂业务逻辑
- 不直接访问数据库，通过DAO层操作数据
- 管理Loro文件系统操作和Subscribe机制

**示例结构**：
```rust
// rust/src/service/card_service.rs
pub struct CardService {
    card_dao: Arc<CardDao>,
    loro_manager: Arc<LoroManager>,
}

impl CardService {
    pub async fn create_card(&self, title: String, content: String) -> Result<Card, ServiceError>
    pub async fn update_card(&self, id: String, title: String, content: String) -> Result<Card, ServiceError>
    pub async fn soft_delete_card(&self, id: String) -> Result<(), ServiceError>
    pub async fn get_cards(&self) -> Result<Vec<Card>, ServiceError>
    pub async fn add_card_to_space(&self, card_id: String, space_id: String) -> Result<(), ServiceError>
}
```

#### 1.3.4 DAO 层（数据访问层）

**职责**：
- 负责数据持久化操作
- SQLite数据库的CRUD操作（通过sea-orm）
- Loro文件系统的读写操作
- 数据模型转换（Entity ↔ Model）

**设计原则**：
- 每个数据模型对应一个DAO（如CardDao、CollaborationSpaceDao）
- 只负责数据访问，不包含业务逻辑
- 使用sea-orm进行类型安全的数据库操作
- 封装Loro文件系统的读写细节

**示例结构**：
```rust
// rust/src/dao/card_dao.rs
pub struct CardDao {
    db_pool: Arc<DatabaseConnection>,
}

impl CardDao {
    pub async fn insert(&self, card: CardEntity) -> Result<CardEntity, DaoError>
    pub async fn update(&self, card: CardEntity) -> Result<CardEntity, DaoError>
    pub async fn delete(&self, id: String) -> Result<(), DaoError>
    pub async fn find_by_id(&self, id: String) -> Result<Option<CardEntity>, DaoError>
    pub async fn find_all_not_deleted(&self) -> Result<Vec<CardEntity>, DaoError>
}
```

#### 1.3.5 层次调用规则

**调用方向**：
- Controller → Service → DAO（单向依赖）
- 上层可以调用下层，下层不能调用上层
- 同层之间可以相互调用（仅限Service层）

**依赖注入**：
- 使用`Arc`进行依赖共享
- Service层依赖DAO层实例
- Controller层依赖Service层实例

**错误传播**：
- DAO层错误 → Service层转换 → Controller层统一处理
- 每层定义自己的错误类型
- 使用`?`操作符简化错误传播

## 2. 前后端通信机制

### 2.1 通信流程
1. Flutter端定义API接口和数据模型
2. 通过flutter_rust_bridge_codegen生成Rust和Flutter的通信代码
3. Rust端实现API接口的业务逻辑
4. Flutter端调用生成的API接口
5. flutter_rust_bridge负责数据序列化和跨语言调用

### 2.2 数据序列化
- 使用protobuf或类似机制进行数据序列化
- 自动生成序列化/反序列化代码
- 支持复杂数据类型的跨语言传输

### 2.3 错误处理
- 定义统一的错误码和错误信息格式
- Rust端返回结构化的错误信息
- Flutter端解析错误信息并显示给用户

## 3. 数据同步机制

### 3.1 CRDT同步原理
- 基于Loro的CRDT算法实现无冲突数据同步
- 每个卡片和协作网络对应一个LoroDoc对象
- LoroDoc使用UUID v7作为唯一标识符

### 3.2 Loro数据持久化策略

#### 3.2.1 文件系统存储结构
```
系统数据目录/
├── db/
│   └── cardmind.db          # SQLite数据库（元数据）
└── loro/
    ├── <base64_uuid_1>/
    │   ├── snapshot.loro    # 快照文件（完整状态）
    │   └── updates.loro     # 增量更新文件
    ├── <base64_uuid_2>/
    │   ├── snapshot.loro
    │   └── updates.loro
    └── ...
```

**设计原理**：
- 每个卡片/网络对应一个独立的文件夹（UUID的base64编码）
- `snapshot.loro`：保存完整的Loro文档快照
- `updates.loro`：保存增量更新数据（追加写入）
- SQLite只存储元数据（title、timestamps等），不存储Loro BLOB

**优势**：
- ✅ 追加写入性能极高（官方推荐）
- ✅ 易于备份和同步单个笔记
- ✅ 避免SQLite BLOB的性能问题
- ✅ 支持增量传输（只传输updates文件）

#### 3.2.2 写操作流程
1. Flutter端调用写操作API（如编辑卡片）
2. Rust端加载对应的LoroDoc（从snapshot + updates）
3. 应用更新到LoroDoc
4. 生成update数据，**追加**到`updates.loro`文件
5. 更新SQLite中的元数据（title、updated_at等）
6. 通过libp2p将update数据同步到其他设备

#### 3.2.3 读操作流程
1. Flutter端调用读操作API
2. Rust端从SQLite读取元数据
3. 如需完整内容，从文件系统加载Loro文档：
   - 加载`snapshot.loro`
   - 应用`updates.loro`中的所有增量更新
4. 返回数据给Flutter端

#### 3.2.4 快照合并策略
当`updates.loro`文件达到阈值（如10MB）时：
1. 将当前完整状态导出为新的snapshot
2. 替换`snapshot.loro`文件
3. 清空`updates.loro`文件
4. 保持数据一致性

### 3.3 设备发现与连接
- 基于libp2p的mDNS协议实现本地网络设备发现
- 设备直接通过libp2p建立P2P连接
- 无需传统的信令服务器

## 4. 数据库设计

### 4.1 SQLite 表结构设计

> **注意**：根据需求文档，设备信息存储在协作网络的 LoroDoc 设备列表中，不需要独立的设备表、网络设备关联表、卡片网络关联表和常驻网络表。这些关联关系都通过 LoroDoc 管理。

#### 4.1.1 卡片表（cards）
| 字段名 | 类型 | 描述 |
|--------|------|------|
| id | TEXT | 卡片唯一标识符（UUID v7） |
| title | TEXT | 卡片标题 |
| content | TEXT | 卡片内容（元数据快照） |
| is_deleted | INTEGER | 删除标记（0=未删除，1=已删除） |
| created_at | INTEGER | 创建时间戳（毫秒） |
| updated_at | INTEGER | 更新时间戳（毫秒） |

**说明**：
- SQLite 仅存储元数据快照，用于快速查询和列表显示
- 完整的 Loro 文档数据存储在文件系统：`loro/<base64(id)>/`
- 通过 Loro Subscribe 机制自动同步数据到 SQLite

#### 4.1.2 协作网络表（collaboration_spaces）
| 字段名 | 类型 | 描述 |
|--------|------|------|
| id | TEXT | 网络唯一标识符（UUID v7） |
| name | TEXT | 网络昵称 |
| password | TEXT | 加密后的网络密码 |
| created_at | INTEGER | 创建时间戳（毫秒） |
| updated_at | INTEGER | 更新时间戳（毫秒） |

**说明**：
- SQLite 仅存储网络元数据
- 设备列表、卡片关联、常驻网络设置等信息存储在 LoroDoc 中
- Loro 文档数据存储在文件系统：`loro/<base64(id)>/`

#### 4.1.3 设备健康检查表（device_health）
| 字段名 | 类型 | 描述 |
|--------|------|------|
| id | TEXT | 设备唯一标识符（设备指纹） |
| name | TEXT | 设备昵称 |
| created_at | INTEGER | 首次初始化时间戳（毫秒） |
| updated_at | INTEGER | 最后更新时间戳（毫秒） |
| last_heartbeat | INTEGER | 最后心跳时间戳（毫秒） |
| status | TEXT | 在线状态（online/offline） |

**说明**：
- 用于在线状态监测，非业务数据表
- 独立维护，用于 P2P 连接状态管理
- 设备的业务信息存储在协作网络的 LoroDoc 设备列表中

## 5. 测试策略

### 5.1 测试分层

#### 5.1.1 单元测试
- **范围**：单个功能模块或函数
- **框架**：Rust测试框架
- **覆盖范围**：≥80%
- **重点测试**：
  - ID生成逻辑
  - 数据验证
  - 核心业务逻辑

#### 5.1.2 集成测试
- **范围**：多个模块协同工作
- **框架**：Rust集成测试框架
- **重点测试**：
  - API接口
  - 数据库操作
  - 前后端通信

#### 5.1.3 功能测试
- **范围**：完整功能流程
- **框架**：Flutter集成测试框架
- **重点测试**：
  - 卡片CRUD操作
  - 网络管理
  - 数据同步

#### 5.1.4 端到端测试
- **范围**：多设备协同工作
- **方法**：使用真实设备或模拟器
- **重点测试**：
  - 多设备同步
  - 网络状态变化
  - 边界情况处理

### 5.2 测试数据管理
- 使用测试专用数据库
- 自动生成测试数据
- 测试前后清理数据

## 6. 部署与构建

### 6.1 构建流程
1. 生成flutter_rust_bridge通信代码
2. 构建Rust核心库
3. 构建Flutter应用
4. 打包生成各平台安装包

### 6.2 依赖管理
- Flutter端使用pub管理依赖
- Rust端使用Cargo管理依赖
- 定期更新依赖版本
- 确保依赖版本兼容性

## 7. 性能优化

### 7.1 读写分离
- 读操作直接访问SQLite
- 写操作通过Loro同步到SQLite
- 减少数据库锁竞争

### 7.2 增量同步
- 使用Loro的增量同步机制
- 仅传输变化的数据
- 减少网络带宽消耗

### 7.3 缓存策略
- 合理使用内存缓存
- 减少数据库访问次数
- 提高响应速度

## 8. 安全设计

### 8.1 数据加密
- 网络密码加密存储
- 设备间通信加密
- 敏感数据保护

### 8.2 身份验证
- 设备指纹识别
- 网络密码验证
- 防止未授权访问

### 8.3 输入验证
- 前后端双重验证
- 防止注入攻击
- 确保数据完整性

## 9. 扩展性设计

### 9.1 模块划分
- 遵循开闭原则
- 模块化设计
- 便于功能扩展

### 9.2 API设计
- 面向接口编程
- 版本化API
- 向后兼容

### 9.3 技术选型
- 选择模块化、可扩展的技术栈
- 支持多种传输协议
- 便于适配新平台