# 系统设计 (System Design)

本文档定义 CardMind 的核心架构原则和设计理念。

**实现细节请查看源码**: 运行 `cargo doc --open` 查看自动生成的 Rust API 文档。

---

## 1. 双层架构原则

### 1.1 设计理念

CardMind 采用**源数据层 (Source of Truth)** 和**查询缓存层 (Query Cache)** 分离的架构。

```
┌─────────────────────────────────────────┐
│           应用层 (Flutter)              │
└─────────────────┬───────────────────────┘
                  │
         ┌────────┴─────────┐
         │                  │
         ▼                  ▼
┌─────────────────┐  ┌─────────────────┐
│  源数据层 (写)   │  │ 查询缓存层 (读)  │
│   Loro CRDT     │──│    SQLite       │
└─────────────────┘  └─────────────────┘
         │                  ▲
         │                  │
         └──────订阅────────┘
```

### 1.2 架构契约

**源数据层职责**:
- 接收所有写操作
- 保证数据一致性
- 支持分布式编辑
- 自动冲突解决 (CRDT)
- 文件持久化
- 触发数据变更通知

**查询缓存层职责**:
- 响应所有读操作
- 提供快速查询
- 索引优化
- 全文搜索 (Phase 3)
- 聚合统计

**不涉及**:
- 具体使用何种 CRDT 实现 (技术选型见 `TECH_CONSTRAINTS.md`)
- SQLite 表结构细节 (数据契约见 `DATA_CONTRACT.md`)
- 订阅机制的代码实现 (查看 `cargo doc`)

---

## 2. 单向数据流契约

### 2.1 数据流向

```
写操作: 用户输入 → 源数据层修改 → 提交变更 → 订阅触发 → 缓存层更新 → UI 刷新
读操作: 用户查询 → 缓存层查询 → 快速返回
```

### 2.2 契约保证

1. **源数据层是唯一的写入点**: 应用层禁止直接写入缓存层
2. **缓存层可随时重建**: 所有数据都能从源数据层恢复
3. **数据流向永不反向**: 缓存层的修改不会回写到源数据层
4. **订阅驱动更新**: 缓存层仅通过订阅机制被动更新

### 2.3 为什么采用单向数据流?

| 方案 | 优点 | 缺点 | 是否采用 |
|------|------|------|---------|
| **双向同步** | 灵活 | 冲突复杂,一致性难保证 | ✗ |
| **单向数据流** | 一致性强,易于调试 | 需严格遵守契约 | ✓ |

**决策理由**: 单向数据流保证了源数据层始终是真理源,缓存层永远是镜像。

---

## 3. 层职责定义

### 3.1 源数据层 (Source Layer)

**定位**: 数据的唯一真理源,负责所有数据修改和持久化。

**职责**:
- 接收用户的创建、更新、删除操作
- 使用 CRDT 算法保证分布式一致性
- 持久化数据到文件系统
- 提供数据变更订阅机制
- 支持 P2P 同步 (Phase 2)

**特性**:
- 自动冲突解决
- 版本历史完整
- 支持离线编辑
- 数据不可篡改

**不擅长**:
- 复杂查询 (无索引)
- 全文搜索
- 聚合统计

### 3.2 查询缓存层 (Query Cache Layer)

**定位**: 只读缓存,负责快速查询和列表展示。

**职责**:
- 响应所有查询请求
- 提供索引优化
- 支持排序和分页
- 支持全文搜索 (Phase 3)
- 数据统计和聚合

**特性**:
- 查询速度快 (毫秒级)
- 支持 SQL 语法
- 可损坏重建 (非关键数据)

**约束**:
- 应用层不可直接写入
- 数据来源仅限订阅更新
- Schema 变更时可删除重建

### 3.3 订阅层 (Subscription Layer)

**定位**: 连接源数据层和缓存层的桥梁。

**职责**:
- 监听源数据层的变更事件
- 解析事件类型 (创建/更新/删除)
- 转换为缓存层的 SQL 操作
- 保证更新的原子性

**流程**:
```
源数据层.commit()
  → 触发订阅回调
  → 解析变更事件
  → 执行缓存层更新 (事务)
  → 确认完成
```

**保证**:
- 订阅回调在同一事务内执行
- 缓存更新失败不影响源数据层
- 订阅顺序与提交顺序一致

### 3.4 数据归属 (单池模型)

- 一个用户 = 一个数据池 (对用户呈现为"笔记空间"),每个设备只能加入一个池
- Pool 文档持有 `card_ids`,是卡片归属的唯一真理源; Card 文档仅存内容字段
- SQLite 订阅回调根据 Pool.card_ids 重建 `card_pool_bindings`,查询层通过该表填充 `Card.pool_id`
- 移除/退出流程均修改 Pool 文档并 commit,确保移除事件跨设备传播; 退出池会清空本地数据并重置 `pool_id`

---

## 4. 架构优势

### 4.1 技术优势

| 维度 | 纯 CRDT | 纯 SQL | 双层架构 |
|------|---------|--------|---------|
| 分布式同步 | ✓ 自动 | ✗ 复杂 | ✓ 由源数据层提供 |
| 快速查询 | ✗ 慢 | ✓ 快 | ✓ 由缓存层提供 |
| 冲突解决 | ✓ CRDT | ✗ 手动 | ✓ 由源数据层提供 |
| 全文搜索 | ✗ 无 | ✓ FTS5 | ✓ 由缓存层提供 |
| 维护成本 | 低 | 低 | 中 (需同步) |

### 4.2 业务优势

1. **数据可靠性**: 源数据层的 CRDT 保证数据永不丢失
2. **查询性能**: 缓存层的索引保证快速响应
3. **离线支持**: 源数据层天然支持离线编辑
4. **P2P 友好**: CRDT 算法适合去中心化同步

### 4.3 权衡

**代价**:
- 需要维护订阅同步机制
- 数据存储占用略高 (两份数据)
- Schema 变更需要同时考虑两层

**收益**:
- 充分利用 CRDT 和关系数据库的优势
- 开发体验好 (SQL 查询熟悉)
- 扩展性强 (缓存层可独立优化)

**结论**: 代价可控,收益显著,适合 CardMind 的业务场景。

---

## 5. 架构演进

### 5.1 Phase 1 - MVP

**目标**: 验证双层架构可行性

**特性**:
- 源数据层: 基本的 CRDT 操作
- 缓存层: 简单的查询和列表
- 订阅层: 实时同步机制

### 5.2 Phase 2 - P2P 同步

**目标**: 实现去中心化同步

**新增**:
- 设备发现 (mDNS/DHT)
- 点对点连接 (libp2p)
- CRDT 同步协议
- 数据池网络

**架构影响**: 仅影响源数据层,缓存层无需改动

### 5.3 Phase 3 - 性能优化

**目标**: 提升查询性能和用户体验

**新增**:
- 全文搜索 (FTS5)
- 标签系统 (可选)
- 批量操作优化
- 分页查询

**架构影响**: 主要优化缓存层,源数据层保持不变

---

## 6. 架构约束

### 6.1 强制约束 (MUST)

1. **所有写操作必须通过源数据层**: 禁止直接写入缓存层
2. **缓存层仅通过订阅更新**: 禁止应用层直接修改缓存
3. **源数据层修改后必须提交**: 调用 `commit()` 触发订阅
4. **缓存层可损坏重建**: 备份策略仅需备份源数据层
5. **单池约束**: 每个设备只能加入一个数据池 (笔记空间); 未加入时禁止创建/同步卡片
6. **归属来源唯一**: 卡片归属仅由 Pool 文档的 `card_ids` 维护; 绑定/解绑必须修改 Pool 并 commit,禁止在 Card 文档写入池关系

### 6.2 建议约束 (SHOULD)

1. **查询优先使用缓存层**: 避免从源数据层遍历数据
2. **批量操作使用事务**: 保证订阅更新的原子性
3. **定期校验一致性**: 检测缓存层与源数据层的同步状态

### 6.3 禁止操作 (MUST NOT)

1. **禁止绕过源数据层直接写缓存**: 破坏单向数据流
2. **禁止在订阅回调中修改源数据层**: 避免循环依赖
3. **禁止假设缓存层永久有效**: 可能损坏或重建

---

## 7. 相关文档

**架构层文档**:
- [DATA_CONTRACT.md](DATA_CONTRACT.md) - 数据契约定义
- [LAYER_SEPARATION.md](LAYER_SEPARATION.md) - 分层策略
- [SYNC_MECHANISM.md](SYNC_MECHANISM.md) - 同步机制设计
- [TECH_CONSTRAINTS.md](TECH_CONSTRAINTS.md) - 技术选型理由

**实现细节**:
- 运行 `cargo doc --open` 查看 Rust API 文档
- 源码位置: `rust/src/store/`

---

## 更新日志

| 版本 | 变更 |
|------|------|
| 1.1.0 | 适配单池模型：更新数据归属说明，强制约束中明确单池要求 |
| 1.0.0 | 初始版本,从 ARCHITECTURE.md 提取设计理念 |

---

**设计哲学**: 本文档定义"系统如何组织",不包含具体代码。实现细节随技术演进变化,设计原则保持稳定。
