# 系统设计 (System Design)

> **设计哲学**: 本文档定义"系统如何组织"，不包含具体代码实现。
> 架构决策背景请查看 [ADR-0002：双层架构决策](../adr/0002-dual-layer-architecture.md)。

**核心原则**: 源数据层 + 查询缓存层 + 订阅驱动

---

## 1. 双层架构原则

### 1.1 设计理念

CardMind 采用**源数据层 (Source of Truth)** 和**查询缓存层 (Query Cache)** 分离的架构。

```
┌─────────────────────────────────────────┐
│           应用层 (Flutter)              │
└─────────────────┬───────────────────────┘
                  │
         ┌────────┴─────────┐
         │                  │
         ▼                  ▼
┌─────────────────┐  ┌─────────────────┐
│  源数据层 (写)   │  │ 查询缓存层 (读)  │
│   Loro CRDT     │──│    SQLite       │
└─────────────────┘  └─────────────────┘
         │                  ▲
         │                  │
         └──────订阅────────┘
```

### 1.2 架构契约

**源数据层职责**:
- 接收所有写操作
- 保证数据一致性
- 支持分布式编辑
- 自动冲突解决 (CRDT)
- 文件持久化
- 触发数据变更通知

**查询缓存层职责**:
- 响应所有读操作
- 提供快速查询
- 索引优化
- 全文搜索 (Phase 3)
- 聚合统计

**决策背景**: 详见 [ADR-0002：为什么采用双层架构](../adr/0002-dual-layer-architecture.md)

---

## 2. 单向数据流契约

### 2.1 数据流向

```
写操作: 用户输入 → 源数据层修改 → 提交变更 → 订阅触发 → 缓存层更新 → UI 刷新
读操作: 用户查询 → 缓存层查询 → 快速返回
```

### 2.2 契约保证

1. **源数据层是唯一的写入点**: 应用层禁止直接写入缓存层
2. **缓存层可随时重建**: 所有数据都能从源数据层恢复
3. **数据流向永不反向**: 缓存层的修改不会回写到源数据层
4. **订阅驱动更新**: 缓存层仅通过订阅机制被动更新

**决策理由**: 详见 [ADR-0002：为什么采用单向数据流](../adr/0002-dual-layer-architecture.md#decision)

---

## 3. 架构约束

### 3.1 强制约束 (MUST)

1. **所有写操作必须通过源数据层**: 禁止直接写入缓存层
2. **缓存层仅通过订阅更新**: 禁止应用层直接修改缓存
3. **源数据层修改后必须提交**: 调用 `commit()` 触发订阅
4. **缓存层可损坏重建**: 备份策略仅需备份源数据层
5. **单池约束**: 每个设备只能加入一个数据池 (笔记空间)
6. **归属来源唯一**: 卡片归属由 Pool 文档的 `card_ids` 维护

### 3.2 建议约束 (SHOULD)

1. **查询优先使用缓存层**: 避免从源数据层遍历数据
2. **批量操作使用事务**: 保证订阅更新的原子性
3. **定期校验一致性**: 检测缓存层与源数据层的同步状态

### 3.3 禁止操作 (MUST NOT)

1. **禁止绕过源数据层直接写缓存**: 破坏单向数据流
2. **禁止在订阅回调中修改源数据层**: 避免循环依赖
3. **禁止假设缓存层永久有效**: 可能损坏或重建

---

## 4. 详细规格 (链接)

### 数据模型规格
- [单池模型核心规格](../specs/rust/single_pool_model_spec.md) - Pool, Card, DeviceConfig
- [Pool CRUD规格](../specs/rust/pool_model_spec.md) - 池的创建/更新/删除
- [CardStore规格](../specs/rust/card_store_spec.md) - 卡片存储操作

### API规格
- [API层统一规格](../specs/rust/api_spec.md) - 所有API的规范定义
- [DeviceConfig规格](../specs/rust/device_config_spec.md) - 设备配置API

### 同步机制
- [同步层规格](../specs/rust/sync_spec.md) - P2P同步详细规范
- [同步机制设计](./sync_mechanism.md) - 订阅驱动原理

### 代码实现
- 运行 `cargo doc --open` 查看 Rust API 文档
- 源码位置: `rust/src/store/`

---

## 5. 相关文档

### 架构文档
- [数据契约](./data_contract.md) - 字段类型和约束说明
- [层分离策略](./layer_separation.md) - 分层详细说明
- [同步机制](./sync_mechanism.md) - 订阅驱动更新原理
- [技术约束](./tech_constraints.md) - 技术选型决策

### 架构决策记录
- [ADR-0001: 单池所有权模型](../adr/0001-single-pool-ownership.md) - 单池模型决策
- [ADR-0002: 双层架构决策](../adr/0002-dual-layer-architecture.md) - 双层架构决策背景

### Spec文档
- 所有功能规格 → [规格中心](../specs/README.md)
- Spec Coding指南 → [SPEC_CODING_GUIDE.md](../specs/SPEC_CODING_GUIDE.md)

---

## 6. 更新日志

| 版本 | 变更 |
|------|------|
| 1.3.0 | 移除决策历史，链接到 ADR-0002 |
| 1.2.0 | 重构：移除实现细节，链接到规格文档 |
| 1.1.0 | 适配单池模型：更新数据归属说明 |
| 1.0.0 | 初始版本，从 ARCHITECTURE.md 提取设计理念 |

---

**设计哲学**: 本文档定义"系统如何组织"，不包含具体代码。实现细节随技术演进变化，设计原则保持稳定。
