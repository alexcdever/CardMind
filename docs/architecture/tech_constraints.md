# 技术选型理由 (Tech Constraints)

本文档阐述 CardMind 各关键技术选型的业务需求、技术要求和决策理由。

**实现细节请查看源码**: 运行 `cargo doc --open` 查看自动生成的 Rust API 文档。

---

## 1. 为什么选择 Loro CRDT?

### 1.1 业务需求

- **支持多设备同时离线编辑**: 用户在手机和电脑上同时编辑笔记
- **联网后自动合并**: 无需手动处理冲突
- **去中心化同步**: 不依赖云服务器,完全本地网络同步
- **数据永不丢失**: 即使多设备同时编辑同一卡片,所有修改都保留

### 1.2 技术要求

- **自动冲突解决算法**: CRDT (Conflict-free Replicated Data Type)
- **文件持久化支持**: 直接存储为文件,无需额外数据库
- **P2P 友好**: 支持点对点同步,无需中心化服务器
- **高性能**: Rust 实现,适合移动和桌面平台
- **细粒度更新**: 只传输变更,减少网络流量

### 1.3 替代方案对比

| 方案 | 自动冲突解决 | P2P 支持 | 文件持久化 | 性能 | 是否采用 |
|------|------------|---------|-----------|------|---------|
| 手动冲突处理 | ❌ | ✓ | ✓ | ✓ | ✗ |
| OT 算法 (Operational Transform) | ✓ | ❌ (需中心化服务器) | ✓ | ✓ | ✗ |
| **Loro CRDT** | ✓ | ✓ | ✓ | ✓ (Rust) | **✓** |
| Yjs | ✓ | ✓ | ❌ (内存数据结构) | ✓ (JS/WASM) | ✗ |
| Automerge | ✓ | ✓ | ✓ | ⚠️ (性能较低) | ✗ |

### 1.4 决策理由

**Loro 是唯一同时满足以下条件的方案**:
1. 自动冲突解决 (CRDT)
2. P2P 支持 (去中心化)
3. 文件持久化 (简单可靠)
4. 高性能 (Rust 实现)

**其他方案的局限**:
- **手动冲突处理**: 用户体验差,需要手动选择保留哪个版本
- **OT 算法**: 需要中心化服务器,不符合去中心化需求
- **Yjs**: 仅支持内存数据结构,无法直接持久化为文件
- **Automerge**: 性能较低,不适合移动平台

---

## 2. 为什么需要 SQLite 缓存?

### 2.1 业务需求

- **快速列表查询**: 用户打开 app 后立即看到卡片列表 (1000+ 卡片)
- **全文搜索**: 用户输入关键词快速找到相关卡片 (Phase 3)
- **按时间/标签排序**: 用户按创建时间或更新时间查看卡片
- **统计功能**: 显示卡片总数、今日新增等统计信息

### 2.2 CRDT 的局限

Loro CRDT 专注于数据一致性和同步,**不擅长查询**:

| 功能 | Loro CRDT | SQLite | 说明 |
|------|----------|--------|------|
| 查询所有卡片 | 遍历 LoroMap,O(n) | 索引查询,O(log n) | SQLite 更快 |
| 按时间排序 | 手动排序,O(n log n) | ORDER BY,使用索引 | SQLite 优化 |
| 全文搜索 | 不支持 | FTS5,专门优化 | SQLite 独有 |
| 分页查询 | 不支持 | LIMIT/OFFSET | SQLite 原生支持 |
| 统计聚合 | 遍历计算 | COUNT/SUM,优化 | SQLite 高效 |

### 2.3 设计决策

**采用双层架构**:
- **Loro CRDT**: 负责写操作、冲突解决、P2P 同步
- **SQLite**: 负责读操作、快速查询、全文搜索

**数据流**:
```
写: 用户编辑 → Loro CRDT → commit() → 订阅触发 → SQLite 更新
读: 用户查询 → SQLite (WHERE is_deleted=0) → 快速返回
```

### 2.4 权衡

**优点**:
- 兼具 CRDT 和关系数据库优势
- 查询性能好 (毫秒级响应)
- 支持复杂查询 (SQL 语法)

**代价**:
- 需维护订阅同步机制
- 数据存储占用略高 (两份数据)

**结论**: 代价可控,收益显著,适合 CardMind 的业务场景。

---

## 3. 为什么用 UUID v7?

### 3.1 业务需求

- **分布式环境下生成唯一 ID**: 多设备同时创建卡片,无需中心化 ID 生成器
- **支持按创建时间排序**: 卡片列表按时间倒序显示
- **无冲突**: ID 冲突概率极低 (< 10^-15)

### 3.2 技术要求

- **全局唯一**: 128 位长度,冲突概率极低
- **时间有序**: 包含时间戳,支持按创建时间排序
- **无需协调**: 分布式生成,无需中心化服务器

### 3.3 版本对比

| 版本 | 唯一性 | 时间有序 | 分布式生成 | 标准化 | 是否采用 |
|------|-------|---------|-----------|-------|---------|
| UUID v4 | ✓ | ❌ | ✓ | ✓ (RFC 4122) | ✗ |
| **UUID v7** | ✓ | ✓ | ✓ | ✓ (IETF Draft) | **✓** |
| ULID | ✓ | ✓ | ✓ | ⚠️ (非标准) | ✗ |
| Snowflake | ✓ | ✓ | ⚠️ (需机器 ID) | ❌ | ✗ |

### 3.4 决策理由

**UUID v7 的优势**:
1. **时间有序**: 前 48 位是 Unix 时间戳 (毫秒级),天然支持按创建时间排序
2. **标准化**: IETF 标准,生态成熟,Rust/Dart 都有成熟库
3. **分布式生成**: 无需中心化 ID 生成器,适合 P2P 场景
4. **全局唯一**: 128 位长度,冲突概率 < 10^-15

**其他方案的局限**:
- **UUID v4**: 随机生成,无时间信息,无法按创建时间排序
- **ULID**: 非 IETF 标准,生态较小,不如 UUID v7 成熟
- **Snowflake**: 需要机器 ID,不适合分布式场景

**示例**:
```
018c8f8e-1a2b-7c3d-9e4f-5a6b7c8d9e0f
^^^^^^^^ ^^^^ ^^^^ ^^^^ ^^^^^^^^^^^^
  时间戳  版本  随机  随机   随机数
```

---

## 4. 为什么用 flutter_rust_bridge?

### 4.1 业务需求

- **跨平台 UI**: Flutter 支持 iOS、Android、Windows、macOS、Linux
- **高性能业务逻辑**: Rust 实现 CRDT、SQLite、P2P 同步
- **类型安全**: 编译时检查,避免运行时错误
- **自动化**: 减少手动编写桥接代码的工作量

### 4.2 技术要求

- **自动生成桥接代码**: Dart ↔ Rust
- **类型安全**: 编译时类型检查
- **支持复杂数据结构**: 嵌套对象、枚举、泛型
- **错误处理**: 自动传递 Rust 错误到 Dart 异常

### 4.3 替代方案对比

| 方案 | 类型安全 | 自动生成 | 性能 | 易用性 | 是否采用 |
|------|---------|---------|------|-------|---------|
| FFI (原生绑定) | ❌ | ❌ | ✓ (最优) | ⚠️ (复杂) | ✗ |
| JSON over FFI | ❌ | ❌ | ⚠️ (序列化开销) | ✓ | ✗ |
| **flutter_rust_bridge** | ✓ | ✓ | ✓ | ✓ | **✓** |

### 4.4 决策理由

**flutter_rust_bridge 的优势**:
1. **自动生成代码**: 只需在 Rust 中定义函数,自动生成 Dart 绑定
2. **类型安全**: 编译时检查,避免类型不匹配错误
3. **支持复杂类型**: 自动序列化 `Vec<T>`, `Option<T>`, `Result<T, E>` 等
4. **错误处理**: Rust 的 `Result` 自动转换为 Dart 的 `Future` 或异常

**其他方案的局限**:
- **原生 FFI**: 手动管理内存,易出错,开发效率低
- **JSON over FFI**: 序列化开销大,类型不安全,需手动编写转换代码

**示例**:
```rust
// Rust 端
#[flutter_rust_bridge::frb(sync)]
pub fn create_card(title: String, content: String) -> Result<Card, CardMindError> {
    // 实现
}

// 自动生成 Dart 端 (bridge_generated.dart)
Future<Card> createCard({required String title, required String content});
```

---

## 5. 为什么用 bcrypt 加密密码? (Phase 2)

### 5.1 业务需求

- **数据池密码保护**: 防止未授权设备访问数据池
- **局域网隐私保护**: 家庭成员在同一 WiFi 下使用 P2P 时，各自的数据池密码不同，数据互不同步
- **典型场景**:
  - 爸爸、妈妈、儿子各有手机和电脑，都在家里 WiFi 下使用 CardMind
  - mDNS 自动发现局域网内所有设备
  - 通过数据池密码隔离，避免三人的数据互相同步
- **安全存储**: 密码哈希存储在 CRDT 中,明文存储在系统 Keyring

### 5.2 技术要求

- **不可逆加密**: 无法从哈希反推明文密码
- **抗暴力破解**: 工作因子可调,增加破解难度
- **盐值自动生成**: 避免彩虹表攻击

### 5.3 算法对比

| 算法 | 不可逆 | 抗暴力破解 | 盐值 | 标准化 | 是否采用 |
|------|-------|-----------|------|-------|---------|
| MD5 | ⚠️ (已破解) | ❌ | ❌ | ❌ | ✗ |
| SHA256 | ✓ | ❌ (速度太快) | ❌ | ❌ | ✗ |
| **bcrypt** | ✓ | ✓ (工作因子可调) | ✓ (自动) | ✓ | **✓** |
| scrypt | ✓ | ✓ | ✓ | ✓ | ⚠️ (内存消耗大) |
| Argon2 | ✓ | ✓ | ✓ | ✓ | ⚠️ (生态较新) |

### 5.4 决策理由

**bcrypt 的优势**:
1. **工作因子可调**: 可以增加计算复杂度,抵抗未来硬件提升
2. **盐值自动生成**: 每次加密自动生成随机盐值,避免彩虹表攻击
3. **生态成熟**: Rust、Dart、Java、Python 都有成熟库
4. **抗暴力破解**: 工作因子 12 下,单次验证耗时 ~100ms,暴力破解不可行

**其他方案的局限**:
- **MD5/SHA256**: 速度太快,易被暴力破解
- **scrypt**: 内存消耗大,不适合移动设备
- **Argon2**: 生态较新,库支持不如 bcrypt 成熟

**工作因子选择**:
- 工作因子 12: 单次验证 ~100ms,平衡安全与性能
- 未来硬件提升时,可增加工作因子到 13 或 14

---

## 6. 为什么用 mDNS 设备发现? (Phase 2)

### 6.1 业务需求

- **本地网络自动发现**: 同一 WiFi 下的设备自动发现彼此
- **无需手动配置**: 用户无需输入 IP 地址或端口
- **隐私保护**: 仅在本地网络广播,不暴露到公网

### 6.2 技术要求

- **零配置**: 无需中心化服务器
- **本地网络**: 仅在局域网内广播
- **标准化**: 跨平台支持 (iOS、Android、Windows、macOS、Linux)

### 6.3 替代方案对比

| 方案 | 零配置 | 本地网络 | 跨平台 | 标准化 | 是否采用 |
|------|-------|---------|-------|-------|---------|
| 手动输入 IP | ❌ | ✓ | ✓ | ✓ | ✗ |
| **mDNS** | ✓ | ✓ | ✓ | ✓ (RFC 6762) | **✓** |
| DHT (分布式哈希表) | ✓ | ❌ (全球网络) | ✓ | ✓ | ⚠️ (Phase 2 可选) |
| 中心化服务器 | ✓ | ❌ | ✓ | ✓ | ✗ (不符合去中心化) |

### 6.4 决策理由

**mDNS 的优势**:
1. **零配置**: 设备自动广播和发现,无需用户输入
2. **本地网络**: 仅在局域网内广播,隐私保护
3. **标准化**: RFC 6762,所有平台都支持 (Bonjour/Avahi)
4. **libp2p 集成**: libp2p 原生支持 mDNS 协议

**其他方案的局限**:
- **手动输入 IP**: 用户体验差,需要技术知识
- **DHT**: 暴露到全球网络,隐私风险高
- **中心化服务器**: 违背去中心化设计理念

**安全保证**:
- mDNS 广播仅包含非敏感信息 (设备 ID、数据池 ID)
- 数据池名称仅在密码验证成功后获取
- 不包含密码、成员列表、卡片内容

---

## 7. 为什么用系统 Keyring 存储密码? (Phase 2)

### 7.1 业务需求

- **安全存储明文密码**: 用户输入的数据池密码需要安全存储
- **自动重连**: App 重启后自动加入已加入的数据池,无需重新输入密码
- **平台原生安全机制**: 利用操作系统的加密存储

### 7.2 平台映射

| 平台 | 安全存储机制 | 加密方式 | Rust Crate |
|------|-------------|---------|-----------|
| iOS | Keychain | 硬件级加密 (Secure Enclave) | `keyring` |
| Android | Keystore / EncryptedSharedPreferences | 硬件支持的加密 | `keyring` |
| Windows | Credential Manager | DPAPI 加密 | `keyring` |
| macOS | Keychain | 加密 | `keyring` |
| Linux | Secret Service API | GNOME Keyring / KWallet | `keyring` |

### 7.3 替代方案对比

| 方案 | 安全性 | 跨平台 | 易用性 | 是否采用 |
|------|-------|--------|-------|---------|
| 明文存储在文件 | ❌ (极不安全) | ✓ | ✓ | ✗ |
| 加密存储在文件 | ⚠️ (密钥管理复杂) | ✓ | ⚠️ | ✗ |
| **系统 Keyring** | ✓ (平台原生) | ✓ (keyring crate) | ✓ | **✓** |

### 7.4 决策理由

**系统 Keyring 的优势**:
1. **平台原生安全**: 利用操作系统的加密机制,无需自己管理密钥
2. **硬件级加密**: iOS/Android 支持硬件加密 (Secure Enclave/Keystore)
3. **跨平台统一 API**: `keyring` crate 提供统一接口
4. **自动清理**: App 卸载时自动清除密码

**其他方案的局限**:
- **明文存储**: 极不安全,任何人都能读取
- **加密存储在文件**: 需要自己管理密钥,复杂且易出错

**密码存储键格式**:
```
cardmind.pool.<pool_id>.password
```

---

## 8. 总结

### 8.1 技术选型矩阵

| 技术选型 | 业务需求 | 替代方案 | 决策理由 |
|---------|---------|---------|---------|
| **Loro CRDT** | 分布式同步、自动冲突解决 | OT、Yjs、Automerge | 唯一满足 CRDT + P2P + 文件持久化 |
| **SQLite** | 快速查询、全文搜索 | 纯 CRDT、NoSQL | CRDT 不擅长查询,双层架构兼具优势 |
| **UUID v7** | 分布式 ID、时间有序 | UUID v4、ULID、Snowflake | IETF 标准,时间有序,分布式生成 |
| **flutter_rust_bridge** | 跨平台 UI + Rust 后端 | FFI、JSON over FFI | 类型安全,自动生成,易用 |
| **bcrypt** | 密码哈希 | MD5、SHA256、Argon2 | 工作因子可调,抗暴力破解,生态成熟 |
| **mDNS** | 本地网络设备发现 | 手动 IP、DHT、中心化服务器 | 零配置,本地网络,标准化 |
| **系统 Keyring** | 安全存储密码 | 明文、加密文件 | 平台原生,硬件加密,跨平台统一 |

### 8.2 核心决策原则

1. **优先标准化技术**: UUID v7、mDNS、bcrypt 都是标准协议
2. **兼顾性能与安全**: Rust 实现高性能,bcrypt 保证安全
3. **平衡复杂度与收益**: 双层架构略增复杂度,但收益显著
4. **跨平台一致性**: 所有技术都支持主流平台

---

## 9. 相关文档

**架构层文档**:
- [SYSTEM_DESIGN.md](SYSTEM_DESIGN.md) - 系统设计原则
- [DATA_CONTRACT.md](DATA_CONTRACT.md) - 数据契约定义
- [LAYER_SEPARATION.md](LAYER_SEPARATION.md) - 分层策略
- [SYNC_MECHANISM.md](SYNC_MECHANISM.md) - 同步机制设计

**实现细节**:
- 运行 `cargo doc --open` 查看 Rust API 文档
- 源码位置: `rust/src/`

---

## 更新日志

| 版本 | 变更 |
|------|------|
| 1.0.0 | 初始版本,从 PRD.md 和 ARCHITECTURE.md 提取技术选型理由 |

---

**设计哲学**: 本文档定义"为什么选择这些技术",使用对比表格展示决策过程,不包含具体实现。技术选型基于业务需求、技术要求和权衡分析。
