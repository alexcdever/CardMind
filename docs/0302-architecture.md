# CardMind 架构设计文档

## 目录

1. [概述](#1-概述)
2. [核心技术概念](#2-核心技术概念)
   2.1 [网络认证与设备管理](#21-网络认证与设备管理)
   2.2 [Yjs CRDT 同步机制](#22-yjs-crdt-同步机制)
   2.3 [双数据源工作方式](#23-双数据源工作方式)
   2.4 [WebRTC 点对点通信](#24-webrtc-点对点通信)
3. [跨平台架构设计](#3-跨平台架构设计)
   3.1 [架构概览](#31-架构概览)
   3.2 [平台优先级与部署能力](#32-平台优先级与部署能力)
   3.3 [平台架构设计](#33-平台架构设计)
   3.4 [后端服务共享架构](#34-后端服务共享架构)
   3.5 [通信优先级策略](#35-通信优先级策略)
   3.6 [平台适配方案](#36-平台适配方案)
   3.7 [移动端接入协作网络机制](#37-移动端接入协作网络机制)
4. [信令服务器设计](#4-信令服务器设计)
5. [数据模型与存储](#5-数据模型与存储)
6. [关键流程](#6-关键流程)
7. [注意事项](#7-注意事项)

## 1. 概述

CardMind基于CRDT数据同步、WebRTC点对点通信和离线优先架构，实现多设备间的无缝数据协作。本文档介绍了CardMind的核心架构设计、技术概念和跨平台实现方案。

## 2. 核心技术概念

### 2.1 网络认证与设备管理

#### 2.1.1 网络ID生成机制
- **UUID v4**: 使用加密安全的随机UUID生成唯一网络标识符
- **可发现性**: 网络ID设计为易分享和识别的格式
- **生成权限**: 每个设备都可以生成网络ID，无主次设备之分
- **唯一性保证**: 使用加密随机数生成，确保全球唯一性

#### 2.1.2 设备ID与昵称管理
- **设备ID生成**: 结合设备指纹和随机UUID生成持久化设备标识
- **本地存储**: 设备ID使用IndexedDB本地持久化存储
- **设备昵称**: 用户友好的设备名称，默认使用设备类型+随机字符组合
- **个性化设置**: 支持用户自定义设备昵称
- **冲突处理**: 当多设备昵称相同时，自动添加后缀确保唯一性

#### 2.1.3 Access Code机制
- **编码算法**: 使用URL安全的Base64编码
- **数据结构**: 包含网络ID、WebRTC连接信息、时间戳和设备标识
- **设计原则**: 不保存Access Code，每次需要时重新生成

### 2.2 Yjs CRDT 同步机制

#### 2.2.1 CRDT 基本原理
- **CRDT**（Conflict-free Replicated Data Type）：无冲突复制数据类型
- **自动合并**：不同设备上的修改可以自动合并
- **强最终一致性**：所有设备最终会收敛到相同状态
- **无中心化**：不依赖中央服务器进行数据同步和冲突解决

#### 2.2.2 Yjs 特性
- **高性能**：即使在高延迟网络环境下也能保持良好性能
- **可扩展性**：支持任意数量的并发编辑者
- **版本历史**：维护操作历史，支持撤销/重做
- **空间效率**：使用delta压缩减少传输数据量
- **持久化**：支持多种持久化方式，包括IndexedDB

### 2.3 双数据源工作方式

#### 2.3.1 双数据源设计理念
- **业务数据存储**：使用IndexedDB存储业务数据，提供结构化查询能力
- **同步数据层**：使用Yjs作为同步层，负责多设备间的实时同步
- **双向同步**：维护两个数据源之间的一致性
- **本地优先**：优先使用本地数据提供快速响应

#### 2.3.2 数据流向
- **写操作**：用户修改 → 更新IndexedDB → 更新Yjs文档 → 同步到其他设备
- **读操作**：优先从IndexedDB读取 → 必要时从Yjs同步
- **冲突解决**：基于时间戳的冲突解决策略

### 2.4 WebRTC 点对点通信

#### 2.4.1 WebRTC 基本原理
- **点对点连接**：直接在浏览器之间建立连接，无需经过服务器中转
- **NAT穿透**：使用ICE/STUN/TURN协议解决NAT穿透问题
- **加密通信**：所有WebRTC通信默认加密

#### 2.4.2 y-webrtc 适配器
- **自动连接管理**：自动管理连接的建立、维护和断开
- **房间概念**：使用命名房间组织协作用户
- **意识协议**：跟踪在线用户状态和光标位置

## 3. 跨平台架构设计

### 3.1 架构概览

```
┌─────────────────────────────────────────────────────────────────┐
│                        客户端层                                   │
├─────────────┬─────────────┬─────────────┬──────────────────────┤
│   Web端     │  Electron   │ React Native│    其他平台          │
│(浏览器环境)  │(桌面环境)    │(移动环境)    │(TV/嵌入式等)        │
└──────┬──────┴──────┬──────┴──────┬──────┴──────┬─────────────────┘
       │             │             │             │
       └─────────────┼─────────────┼─────────────┼─────────────────┘
                     │             │             │
              ┌──────▼─────────────────────────────▼─────────────────┐
              │              通信适配层                               │
              │  ┌─────────────┬─────────────┬────────────────────┐  │
              │  │ 平台检测  │  连接策略   │   协议适配         │  │
              │  └─────────────┴─────────────┴────────────────────┘  │
              └──────────────────┬─────────────────────────────────┘
                                 │
              ┌──────────────────┼─────────────────────────────────┐
              │                  │                                 │
       ┌──────▼──────┐    ┌──────▼──────┐                  ┌──────▼──────┐
       │本地通信优先 │                  │云信令服务  │
       │BroadcastChan│                  │WebSocket   │
       │IPC(原生)    │                  │Serverless  │
       └──────┬──────┘    └──────┬──────┘                  └──────┬──────┘
              │                  │                                 │
              └──────────────────┼─────────────────────────────────┘
                                 │
              ┌──────────────────▼─────────────────────────────────┐
              │              WebRTC核心层                        │
              │  ┌─────────────┬─────────────┬────────────────────┐  │
              │  │ 连接管理   │  NAT穿透    │   数据通道         │  │
              │  │ 状态监控   │  ICE处理    │   加密传输         │  │
              │  └─────────────┴─────────────┴────────────────────┘  │
              └──────────────────┬─────────────────────────────────┘
                                 │
              ┌──────────────────▼─────────────────────────────────┐
              │              Yjs CRDT层                         │
              │  ┌─────────────┬─────────────┬────────────────────┐  │
              │  │ 文档同步   │ 冲突解决    │   状态管理         │  │
              │  │ 版本控制   │ 合并策略    │   持久化           │  │
              │  └─────────────┴─────────────┴────────────────────┘  │
              └──────────────────┬─────────────────────────────────┘
                                 │
              ┌──────────────────▼─────────────────────────────────┐
              │              数据存储层                         │
              │  ┌─────────────┬─────────────┬────────────────────┐  │
              │  │ IndexedDB  │ AsyncStorage│   SQLite         │  │
              │  │ (Web/桌面)  │ (RN)        │   (原生)         │  │
              │  └─────────────┴─────────────┴────────────────────┘  │
              └──────────────────────────────────────────────────┘
```

### 3.2 平台优先级与部署能力

| 平台类型 | 优先级 | 落地顺序 | 部署能力 | 主要角色 |
|---------|--------|----------|----------|----------|
| Electron (PC) | 最高 | 1 | 客户端+服务端 | 数据中心、信令服务、局域网同步中心 |
| React Native (移动端) | 中等 | 2 | 仅客户端 | 移动访问终端、依赖其他平台服务 |
| Web 平台 | 最低 | 3 | 客户端+服务端 | 跨网络信令服务、全球访问入口、前后端分离架构 |

> 详细的开发策略和部署策略请参考 [0301-tech-stack.md](0301-tech-stack.md)

### 3.3 平台架构设计

#### 3.3.1 Web平台架构
- **完整前后端能力**：可部署在Linux或Docker环境中
  - **前端**：以Web页面形式运行在浏览器中，使用React + TypeScript开发
  - **后端**：运行在服务器环境中，提供API服务和信令服务
  - **部署方式**：支持容器化部署、云服务器部署和Serverless部署
  - **技术栈**：Node.js + WebSocket + 数据库

#### 3.3.2 Electron平台架构
- **桌面应用**：基于Web技术栈，封装为桌面应用
  - **通信机制**：IPC通信 + WebSocket
  - **存储方案**：IndexedDB + Node.js fs模块

  - **后端集成**：可内置完整的后端服务

#### 3.3.3 React Native平台架构
- **移动应用**：基于React技术栈，编译为原生移动应用
  - **通信机制**：WebSocket + 原生事件桥
  - **存储方案**：AsyncStorage + SQLite

  - **服务依赖**：依赖其他平台提供的后端服务

### 3.4 后端服务共享架构

#### 3.4.1 架构设计

```
┌─────────────────────────────────────────────────────────────────┐
│                       后端服务层                                 │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                     共享后端服务代码                        │  │
│  │  ┌─────────────┬─────────────┬────────────────────┐      │  │
│  │  │ 信令服务   │  Yjs文档管理 │   API服务          │      │  │
│  │  └─────────────┴─────────────┴────────────────────┘      │  │
│  └────────────────────────┬────────────────────────────────┘  │
│                           │                                    │
└───────────────────────────┼─────────────────────────────────────┘
                           │
              ┌─────────────▼─────────────┐
              │        部署适配层          │
              ├─────────────┬─────────────┤
              │ Electron   │   Web平台    │
              │ 子进程形式  │  容器/云部署  │
              └──────┬──────┴──────┬──────┘
                     │             │
       ┌─────────────▼──────┐ ┌────▼─────────────┐
       │  Electron客户端     │ │   Web客户端      │
       │ (桌面应用)         │ │ (浏览器)         │
       └────────────────────┘ └──────────────────┘
```

#### 3.4.1.1 子进程实现机制

##### 3.4.1.1.1 Electron子进程管理
```typescript
// Electron主进程中的子进程管理
import { spawn } from 'child_process';
import path from 'path';

class BackendProcessManager {
  private backendProcess: ChildProcess | null = null;

  async startBackend() {
    // 获取后端服务入口文件路径
    const backendPath = path.join(__dirname, '../backend/server.js');
    
    // 启动后端服务子进程
    this.backendProcess = spawn('node', [backendPath], {
      stdio: ['ignore', 'pipe', 'pipe', 'ipc'],
      env: {
        ...process.env,
        PORT: '3001', // 为Electron后端服务指定端口
        NODE_ENV: 'production'
      }
    });

    // 监听子进程输出和退出事件
    // ...

    // 等待后端服务启动完成
    await this.waitForBackendReady();
  }

  async stopBackend() {
    if (this.backendProcess) {
      this.backendProcess.kill();
      this.backendProcess = null;
    }
  }

  private async waitForBackendReady() {
    // 实现等待后端服务启动完成的逻辑
    // ...
  }
}
```

##### 3.4.1.1.2 进程间通信方案
- **推荐使用HTTP/WebSocket**：标准化、简单、无需修改后端代码
- **Electron IPC**：仅用于Electron内部组件通信
- **通信客户端**：封装统一的通信接口，屏蔽不同平台的通信差异

##### 3.4.1.1.3 优势
- **代码完全共享**：无需为Electron编写兼容性代码
- **独立运行环境**：后端服务不受Electron环境影响
- **简化部署适配层**：只需要处理子进程的启动、停止和通信
- **跨平台一致性**：Electron和Web平台使用相同的后端部署逻辑

#### 3.4.2 备选架构（Web后端为主）

```
┌─────────────────────────────────────────────────────────────────┐
│                       Web后端服务                               │
│  ┌─────────────┬─────────────┬────────────────────┐              │
│  │ 信令服务   │  Yjs文档管理 │   API服务          │              │
│  └─────────────┴─────────────┴────────────────────┘              │
└────────────────────────┬───────────────────────────────────────┘
                         │
              ┌──────────▼──────────┐
              │  服务适配层          │
              │  (Electron专用)      │
              └──────────┬──────────┘
                         │
       ┌─────────────────▼─────────────────┐
       │          Electron客户端           │
       │      (集成适配后的后端服务)        │
       └───────────────────────────────────┘
```

#### 3.4.3 代码共享实现策略
1. **模块化设计**：将后端服务拆分为独立模块，便于不同平台复用
2. **平台抽象层**：为不同平台提供统一的API接口，内部实现适配不同平台
3. **配置驱动**：通过配置文件控制服务的启动和行为，适应不同平台需求
4. **依赖管理**：使用统一的依赖管理工具，确保不同平台使用相同版本的依赖
5. **测试策略**：编写跨平台的测试用例，确保代码在不同平台上的一致性

### 3.5 通信优先级策略

#### 3.5.1 连接优先级（按速度和稳定性排序）
1. **同一设备内**（速度最快，延迟最低）
   - Web: BroadcastChannel
   - Electron: IPC通信
   - React Native: Native Event Bridge

2. **同一局域网**（速度较快，无网络成本）
   - 直接IP连接
   - 本地WebSocket服务器

3. **跨网络/互联网**（覆盖范围广，需要服务器）
   - 云信令服务器
   - STUN/TURN服务器协助NAT穿透
   - 完全P2P数据传输

#### 3.5.2 自动降级机制
```typescript
class ConnectionManager {
  async establishConnection(targetDevice: DeviceInfo): Promise<Connection> {
    // 1. 尝试同一设备内通信
    if (this.isSameDevice(targetDevice)) {
      return await this.tryIntraDeviceConnection();
    }
    
    // 2. 尝试局域网发现
    const localConnection = await this.tryLocalNetworkDiscovery();
    if (localConnection) {
      return localConnection;
    }
    
    // 3. 使用云信令服务
    return await this.establishCloudSignalingConnection();
  }
}
```

### 3.6 平台适配方案

#### 3.6.1 Web平台适配
- **前端**:
  - **通信机制**: BroadcastChannel + WebSocket
  - **存储方案**: IndexedDB（通过Dexie.js）

- **后端**:
  - **部署方式**: 支持容器化部署、云服务器部署和Serverless部署
  - **服务组件**: 信令服务、Yjs文档管理、API服务
  - **技术栈**: Node.js + WebSocket + 数据库
- **前后端交互**: RESTful API + WebSocket实时通信

#### 3.6.2 Electron平台适配
- **通信机制**: IPC通信 + WebSocket
- **存储方案**: IndexedDB + Node.js fs模块
- **服务端部署**: 内置信令服务，支持本地部署


#### 3.6.3 React Native平台适配
- **通信机制**: WebSocket + 原生事件桥
- **存储方案**: AsyncStorage + SQLite
- **服务端依赖**: 依赖PC或Web平台的服务


### 3.7 移动端接入协作网络机制

#### 3.7.1 同一局域网内
1. **设备连接**：
   - 手动输入PC端的IP地址

2. **连接建立**：
   - 移动端直接连接到PC端的服务
   - 使用WebRTC建立点对点连接
   - 数据直接在移动端和PC端之间传输

3. **数据同步**：
   - 通过Yjs CRDT算法实现数据同步
   - PC端作为数据中心，存储完整数据
   - 移动端可以只存储最近使用的数据

#### 3.7.2 跨网络
1. **信令服务接入**：
   - 移动端连接到web平台的信令服务
   - 或者连接到公网可访问的PC端服务

2. **设备发现**：
   - 通过信令服务发现网络中的其他设备
   - 信令服务维护网络成员列表

3. **连接建立**：
   - 通过信令服务交换WebRTC连接信息
   - 建立跨网络的点对点连接
   - 或者通过服务端中转数据

4. **数据同步**：
   - 通过Yjs CRDT算法实现数据同步
   - 服务端作为数据备份和中转中心
   - 支持增量同步，减少网络传输量

## 4. 信令服务器设计

### 4.1 轻量级信令服务器

#### 4.1.1 核心功能
- WebSocket连接管理
- 房间管理和消息广播
- 设备发现和状态跟踪
- WebRTC信令转发

#### 4.1.2 部署方案
- **Docker容器化**: 支持容器化部署
- **Serverless**: 支持Vercel等Serverless平台
- **本地部署**: 支持Electron/React Native内置信令服务

## 5. 数据模型与存储

### 5.1 核心数据实体

- **Card**：卡片实体
  - `id`：唯一标识符
  - `title`：卡片标题
  - `content`：卡片内容
  - `createdAt`：创建时间
  - `updatedAt`：更新时间
  - `isDeleted`：软删除标记
  - `lastModifiedBy`：最后修改设备ID

- **Network**：协作网络实体
  - `id`：网络唯一标识符（UUID）
  - `createdAt`：网络创建时间
  - `devices`：已加入设备列表
  - `lastActivity`：最后活动时间

- **Device**：设备实体
  - `id`：设备唯一标识符
  - `nickname`：设备昵称
  - `deviceType`：设备类型
  - `createdAt`：设备记录创建时间
  - `lastSeen`：最后在线时间

### 5.2 存储策略

#### 5.2.1 客户端存储
- **业务数据**：使用Dexie.js管理IndexedDB
- **同步数据**：使用Yjs管理同步状态
- **持久化**：使用y-indexeddb持久化Yjs文档
- **索引优化**：为常用查询字段创建索引

#### 5.2.2 服务端Yjs持久化

##### 5.2.2.1 设计理念
- **解决存储限制**：应对浏览器和移动端的存储容量限制
- **数据备份**：提供中心化的数据备份，防止设备丢失或损坏
- **跨网络同步**：改善跨网络设备的同步体验
- **分层存储**：客户端存储最近使用的数据，服务端存储完整数据

##### 5.2.2.2 实现架构
```typescript
// 服务端Yjs文档管理器
class YjsDocumentManager {
  private documents: Map<string, Y.Doc> = new Map();
  private persistence: Y.Doc[] = [];

  async getDocument(networkId: string): Promise<Y.Doc> {
    // 如果文档已存在，直接返回
    if (this.documents.has(networkId)) {
      return this.documents.get(networkId)!;
    }

    // 从持久化存储加载文档
    const doc = await this.loadDocumentFromStorage(networkId);
    
    // 添加到文档映射
    this.documents.set(networkId, doc);
    
    // 监听文档变更，自动持久化
    doc.on('update', async (update) => {
      await this.persistDocumentUpdate(networkId, update);
    });

    return doc;
  }

  // 其他方法：加载、持久化、清理等
}
```

##### 5.2.2.3 部署方案
- **基于共享后端代码**：
  - **Electron端**：内置Yjs文档管理器，使用Node.js fs模块存储到本地文件系统
  - **Web平台后端**：部署到云服务器或容器中，使用数据库存储Yjs文档
- **容器化部署**：支持Docker容器化，便于水平扩展和负载均衡
- **Serverless部署**：Web平台后端支持Serverless部署，降低运营成本
- **统一配置管理**：使用环境变量或配置文件统一管理不同部署环境的配置

##### 5.2.2.4 数据同步策略
1. **客户端优先**：客户端先尝试从本地加载数据，同时从服务端同步最新数据
2. **增量同步**：只同步变更的数据，减少网络传输量
3. **按需加载**：客户端可以只加载最近使用的数据，历史数据从服务端按需获取
4. **自动合并**：使用Yjs CRDT算法自动合并冲突

##### 5.2.2.5 优势
- **高可用性**：无单点故障，服务端不可用时客户端仍可工作
- **低延迟**：数据直接在设备间传输，减少中间环节
- **隐私安全**：数据不经过第三方服务器，降低泄露风险
- **低成本**：信令服务器资源消耗小，运营成本低

##### 5.2.2.6 挑战与解决方案
| 挑战 | 解决方案 |
|------|----------|
| NAT穿透困难 | 集成STUN/TURN服务器协助NAT穿透 |
| 数据一致性 | 使用成熟的Yjs库实现自动冲突解决 |
| 设备管理复杂 | 设计清晰的设备管理API，提供统一的设备管理界面 |

## 6. 关键流程

### 6.1 网络认证流程
- 检查设备ID
- 网络状态检查
- Access Code输入/生成
- 网络加入
- 设备注册

### 6.2 应用启动流程
- 初始化IndexedDB
- 加载设备信息
- 加载网络配置
- 建立WebRTC连接
- 同步数据
- 监听变更

### 6.3 数据操作同步流程
- 本地操作
- 本地保存
- 同步标记
- 实时传播
- 远程应用
- 双向同步

## 7. 注意事项

### 7.1 数据一致性
- CRDT算法确保最终一致性
- 双数据源设计需要仔细处理同步冲突
- 离线操作可能导致合并冲突

### 7.2 网络连接限制
- WebRTC连接需要网络支持UDP流量
- 某些企业网络环境可能限制WebRTC连接
- NAT穿透在某些复杂网络环境下可能失败

### 7.3 性能考虑
- Yjs文档大小会影响同步性能
- 大量并发编辑可能导致性能下降
- IndexedDB查询需要合理设计索引

### 7.4 安全考虑
- Access Code需要安全生成和传输
- WebRTC连接默认加密，但仍需验证设备身份
- 本地数据存储需要加密保护