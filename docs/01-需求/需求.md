# CardMind 需求文档

## 1. 产品概述

CardMind 是一个基于 CRDT 技术的分布式卡片笔记应用，支持多设备间实时数据同步。

**目标平台**：
- 桌面端：Windows、macOS、Linux
- 移动端：Android、iOS

**核心设计理念**：
- 每个协作网络作为独立的数据池
- 设备作为数据池的出入口
- 所有数据类型（卡片、协作网络、设备）均支持完整的 CRUD 操作

---

## 2. 数据模型

### 2.1 卡片（Card）

| 属性 | 类型 | 说明 |
|------|------|------|
| id | UUID v7 | 卡片唯一标识，与 LoroDoc ID 一致 |
| 标题 | String | 卡片标题 |
| 内容 | String | 卡片正文内容 |
| 删除标记 | Boolean | 软删除标识 |
| 创建时间 | DateTime | 创建时间戳 |
| 更新时间 | DateTime | 最后更新时间戳 |

**数据关联**：
- 一个卡片对应一个 LoroDoc 对象

**默认行为**：
- 未设置常驻网络时，新建卡片不加入任何协作网络
- 支持动态加入/退出任意协作网络

### 2.2 协作网络（CollaborationSpace）

| 属性 | 类型 | 说明 |
|------|------|------|
| id | UUID v7 | 网络唯一标识，与 LoroDoc ID 一致 |
| 昵称 | String | 网络显示名称 |
| 密码 | String | 访问密码 |
| 设备列表 | Array | 已加入的设备列表 |
| 创建时间 | DateTime | 创建时间戳 |
| 更新时间 | DateTime | 最后更新时间戳 |

**数据关联**：
- 一个协作网络对应一个 LoroDoc 对象

**生命周期规则**：
- 所有设备退出后，协作网络自动消失

**加入条件**：
- 验证正确的网络 ID 和密码
- 通过 libp2p 成功建立 P2P 连接

### 2.3 设备（Device）

| 属性 | 类型 | 说明 |
|------|------|------|
| id | String | 设备唯一标识（基于设备指纹生成） |
| 昵称 | String | 设备显示名称 |
| 创建时间 | DateTime | 首次初始化时间 |
| 更新时间 | DateTime | 最后更新时间戳 |

**数据存储说明**：
- 设备信息存储在协作网络的 LoroDoc 设备列表中
- 无独立的设备数据表
- 另有独立的 SQLite 健康检查表用于在线状态监测（详见 3.4 节）

**命名规则**：
- 默认昵称格式：`设备型号-ID前6位`（如：iPhone-abc123）

**初始化行为**：
- 自动创建默认协作网络并加入
- 支持后续自由加入/退出其他协作网络

---

## 3. 技术架构

### 3.1 技术栈概览

| 层级 | 技术选型 | 用途 |
|------|---------|------|
| 前端框架 | Flutter | UI 渲染、权限管理 |
| 后端语言 | Rust | 核心业务逻辑 |
| 同步协议 | Loro (CRDT) | 无冲突数据同步 |
| 网络层 | libp2p | P2P 组网与通信 |
| 数据库 | SQLite + sea-orm | 数据持久化 |
| 跨语言桥接 | flutter_rust_bridge | Dart ↔ Rust 通信 |
| ID 生成 | UUID v7 | 分布式唯一标识 |

### 3.2 核心架构设计

#### 3.2.1 CRDT 同步机制

- 基于 Loro 实现分布式数据无冲突同步
- 每个卡片/网络对应独立的 LoroDoc 对象
- LoroDoc 以文件形式存储在磁盘上（snapshot + updates 增量文件）

#### 3.2.2 P2P 网络拓扑

**服务发现**：
- 基于 libp2p 内置的服务发现能力
- 本地网络：通过 mDNS 协议自动发现设备
- 去中心化设计，无需传统信令服务器

**连接管理**：
- 设备间通过 libp2p 直接建立 P2P 连接
- 替代 WebRTC 和传统信令服务

#### 3.2.3 读写分离架构

> **核心设计目标**：提高系统性能和响应速度

**写操作路径**：
```
Flutter (写请求)
  ↓
Rust 业务层
  ↓
Loro (CRDT 处理)
  ↓
Subscribe 机制触发
  ↓
SQLite 自动更新
```

**读操作路径**：
```
Flutter
  ↓
SQLite (直接查询最新数据)
```

### 3.3 前后端分工

**Flutter 端职责**：
- UI 渲染和交互
- 网络权限申请
- 不直接依赖 loro-dart

**Rust 端职责**：
- 核心业务逻辑实现
- 数据存储与同步
- 设备组网与 P2P 通信
- 依赖：loro、libp2p、sea-orm

**通信规范**：
- 通过 flutter_rust_bridge 进行跨语言调用
- Rust 端遵循开闭原则提供 API

### 3.4 数据持久化策略

**双层存储架构**：
- **SQLite 数据库**：存储元数据快照，用于快速查询
- **Loro 文件系统**：存储完整的 LoroDoc 数据（snapshot + updates 增量文件）

**文件系统结构**：
```
系统数据目录/
├── db/
│   └── cardmind.db          # SQLite数据库（元数据）
└── loro/
    ├── <base64_uuid_1>/
    │   ├── snapshot.loro    # 快照文件（完整状态）
    │   └── updates.loro     # 增量更新文件
    └── <base64_uuid_2>/
        ├── snapshot.loro
        └── updates.loro
```

**SQLite 表结构设计**：

1. **卡片表（cards）**
   - 存储卡片元数据快照（用于快速查询和列表显示）
   - 字段：id, 标题, 内容, 删除标记, 创建时间, 更新时间

2. **协作网络表（collaboration_spaces）**
   - 存储协作网络元数据快照
   - 字段：id, 昵称, 密码, 创建时间, 更新时间

3. **设备健康检查表（device_health）**
   - 用于在线状态监测，非业务数据表
   - 基于设备模型属性扩展
   - 字段：id（设备ID）, 昵称, 创建时间, 更新时间, last_heartbeat（最后心跳时间）, status（在线状态）

**设计目标**：
- SQLite 作为查询层，存储最新元数据快照
- Loro 文件系统存储完整 CRDT 数据，支持增量同步
- 通过 Loro Subscribe 机制自动保持 SQLite 数据一致性
- 健康检查表独立维护，用于 P2P 连接状态管理

---

## 4. 应用行为规范

### 4.1 初始化流程

1. 生成设备唯一 ID（基于设备指纹）
2. 创建默认设备昵称
3. 自动创建一个默认协作网络
4. 设备加入该默认网络

### 4.2 常驻网络机制

**功能说明**：
- 支持将多个协作网络设置为"常驻网络"
- 设置后，新建卡片自动加入所有常驻网络

### 4.3 关键操作流程

#### 设备退出协作网络

**前置检查**：
1. 检查当前设备是否有卡片关联该协作网络
2. 若存在关联，弹出确认提示

**退出操作**：
1. 用户确认后执行退出
2. 自动解除所有关联卡片与该网络的绑定关系
3. 若该网络无其他设备，网络自动销毁
