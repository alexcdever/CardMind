# SQLite 缓存架构规格

## 概述

本规格定义了 CardMind 的 SQLite 缓存层，提供对卡片和池数据的快速读取访问，同时与 Loro CRDT 层保持最终一致性。

**技术栈**:
- **rusqlite** = "0.31" - SQLite Rust 绑定
- **r2d2** = "0.8" - 连接池管理
- **r2d2_sqlite** = "0.24" - SQLite 连接池适配器
- **tokio** - 异步运行时

**核心职责**:
- 为卡片和池数据提供快速索引查询
- 与 Loro 文档保持最终一致性
- 支持复杂查询（过滤、排序、分页）
- 启用全文搜索功能

---

## 需求：数据库 Schema

系统应维护具有优化 schema 的 SQLite 数据库以进行读取操作。

### 场景：Cards 表 schema

- **前置条件**: 数据库初始化
- **操作**: 创建 cards 表
- **预期结果**: 应创建包含所有必需字段的表
- **并且**: 应创建优化查询的索引

**Schema 定义**:


**字段描述**:
- `id`: 卡片 ID（UUIDv7）
- `title`: 卡片标题（索引用于搜索）
- `content`: 卡片内容（Markdown）
- `created_at`: 创建时间戳（Unix 毫秒）
- `updated_at`: 最后更新时间戳（索引用于排序）
- `deleted`: 软删除标志（索引用于过滤）

### 场景：Pools 表 schema

- **前置条件**: 数据库初始化
- **操作**: 创建 pools 表
- **预期结果**: 应创建池元数据表

**Schema 定义**:


### 场景：Card-Pool 绑定表 schema

- **前置条件**: 数据库初始化
- **操作**: 创建 card_pool_bindings 表
- **预期结果**: 应创建关系表
- **并且**: 应设置外键约束

**Schema 定义**:


**理由**:
- 复合主键确保唯一的卡片-池关系
- 外键维护引用完整性
- 两列上的索引支持双向查询

---

## 需求：全文搜索

系统应使用 SQLite FTS5 支持对卡片标题和内容的全文搜索。

### 场景：卡片的 FTS5 虚拟表

- **前置条件**: cards 表已创建
- **操作**: 创建 FTS5 虚拟表和触发器
- **预期结果**: 应创建全文搜索索引
- **并且**: 应自动与 cards 表保持同步

**Schema 定义**:


### 场景：按关键词搜索卡片

- **前置条件**: 多张具有不同内容的卡片
- **操作**: 用户搜索 "rust programming"
- **预期结果**: 系统应返回包含这些关键词的卡片
- **并且**: 结果应按相关性排序

---

## 需求：查询优化

系统应使用索引和查询规划优化常见查询。

### 场景：获取当前池中的所有卡片（按更新时间排序）

- **前置条件**: 池中有多张卡片
- **操作**: 查询池中的卡片
- **预期结果**: 应返回按更新时间排序的卡片
- **并且**: 查询应使用索引优化

### 场景：统计池中的卡片数量

- **前置条件**: 池存在
- **操作**: 统计池中的卡片
- **预期结果**: 应返回准确的卡片数量

### 场景：按创建时间获取最新卡片

- **前置条件**: 池中有多张卡片
- **操作**: 获取最新创建的卡片
- **预期结果**: 应返回按创建时间排序的卡片

---

## 需求：数据库配置

系统应配置 SQLite 以获得最佳性能和持久性。

### 场景：SQLite 性能配置

- **前置条件**: 数据库连接已建立
- **操作**: 配置性能参数
- **预期结果**: 应优化数据库性能

**配置理由**:
- **WAL 模式**: 允许写入期间的并发读取
- **缓存大小**: 减少频繁访问数据的磁盘 I/O
- **同步 NORMAL**: 平衡持久性和性能
- **外键**: 维护引用完整性
- **内存临时存储**: 更快的临时操作
- **内存映射 I/O**: 提高大型数据库的读取性能

---

## 需求：连接池

系统应使用连接池高效管理数据库连接。

### 场景：并发访问的连接池

- **前置条件**: 应用启动
- **操作**: 初始化连接池
- **预期结果**: 应创建可复用的连接池
- **并且**: 应支持并发访问

---

## 需求：事务管理

系统应使用事务进行原子更新以维护一致性。

### 场景：使用事务批量更新

- **前置条件**: 需要更新多张卡片
- **操作**: 批量更新
- **预期结果**: 应原子地更新所有卡片
- **并且**: 失败时应回滚

---

## 需求：数据库维护

系统应提供数据库维护操作以保持数据库健康。

### 场景：清理数据库以回收空间

- **前置条件**: 数据库有已删除的数据
- **操作**: 运行 VACUUM
- **预期结果**: 应回收磁盘空间

### 场景：优化查询性能

- **前置条件**: 数据库有大量数据
- **操作**: 运行 ANALYZE
- **预期结果**: 应更新查询统计信息

---

## 补充说明

**技术栈**:
- **rusqlite** = "0.31" - SQLite Rust 绑定
- **r2d2** = "0.8" - 连接池管理
- **r2d2_sqlite** = "0.24" - SQLite 连接池适配器
- **tokio** - 异步运行时

**设计模式**:
- **仓储模式**: SqliteCache 作为数据访问层
- **连接池模式**: 高效的连接管理
- **事务模式**: 原子批量更新
- **索引策略**: 优化常见查询路径

**性能特征**:
- **并发读取**: WAL 模式下无限制
- **连接池大小**: 默认 10 个连接

**内存使用**:
- **缓存大小**: 10MB
- **内存映射**: 256MB
- **连接池**: ~1MB per connection

---

## 相关文档

**架构规格**:
- [./dual_layer.md](./dual_layer.md) - 双层架构
- [./card_store.md](./card_store.md) - CardStore 实现
- [./pool_store.md](./pool_store.md) - PoolStore 实现
- [./loro_integration.md](./loro_integration.md) - Loro 集成
- [../sync/subscription.md](../sync/subscription.md) - 订阅机制

**领域规格**:
- [../../domain/card.md](../../domain/card.md) - 卡片模型
- [../../domain/pool.md](../../domain/pool.md) - 池模型

---

## 测试覆盖

**测试文件**: `rust/tests/sqlite_cache_feature_test.rs`

**单元测试**:
- `test_schema_creation()` - Schema 初始化
- `test_insert_and_query_card()` - 基本 CRUD 操作
- `test_full_text_search()` - FTS5 搜索
- `test_fts5_triggers()` - FTS5 触发器同步
- `test_pagination()` - 分页查询
- `test_count_cards()` - 卡片统计
- `test_recent_cards()` - 最新卡片查询
- `test_transaction_commit()` - 事务提交
- `test_transaction_rollback()` - 事务回滚
- `test_batch_update()` - 批量更新
- `test_connection_pool()` - 连接池
- `test_connection_timeout()` - 连接超时
- `test_vacuum()` - 数据库清理
- `test_analyze()` - 数据库分析
- `test_integrity_check()` - 完整性检查
- `test_foreign_key_constraints()` - 外键约束

**验收标准**:
- [x] 所有单元测试通过
- [x] FTS5 搜索正确工作
- [x] 连接池高效
- [x] 事务正确处理
- [x] 代码审查通过
