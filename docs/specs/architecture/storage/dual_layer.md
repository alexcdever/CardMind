# 双层存储架构规格

## 概述

本规格定义了双层存储架构，将写操作（Loro CRDT）与读操作（SQLite 缓存）分离，在保持查询性能的同时实现无冲突同步。

**技术栈**:
- **loro** = "1.0" - CRDT 文档存储
- **rusqlite** = "0.31" - SQLite 数据库
- **tokio** - 异步运行时
- **serde** = "1.0" - 序列化/反序列化

**架构模式**:


**核心原则**:
- **单一数据源**: Loro 文档是权威数据源
- **读写分离**: 为每层优化其用途
- **最终一致性**: SQLite 最终反映 Loro 状态
- **订阅驱动**: 更新自动传播

---

## 需求：写入层 - Loro CRDT

系统应使用 Loro CRDT 文档作为所有写操作的权威数据源。

### 场景：所有写入首先进入 Loro

- **前置条件**: 用户修改卡片
- **操作**: 保存修改
- **预期结果**: 变更应首先写入 Loro 文档
- **并且**: Loro 文档应持久化到磁盘
- **并且**: SQLite 缓存应通过订阅更新

**理由**:
- Loro 为 P2P 同步提供无冲突合并
- CRDT 保证跨设备的最终一致性
- Loro 文档可以在对等设备间直接同步

### 场景：卡片的 Loro 文档结构

- **前置条件**: 系统需要定义卡片的 CRDT 文档结构
- **操作**: 设定卡片的 Loro 文档字段
- **预期结果**: 文档包含卡片核心字段
- **并且**: 字段使用 UUIDv7 与毫秒级时间戳

**文档结构**:


**文件位置**:
- 路径: `data/loro/<card_id>/snapshot.loro`
- 格式: Loro 二进制快照

### 场景：池的 Loro 文档结构

- **前置条件**: 系统需要定义池的 CRDT 文档结构
- **操作**: 设定池的 Loro 文档字段
- **预期结果**: 文档包含池与成员列表信息
- **并且**: 列表字段使用 Loro List CRDT

**文档结构**:


**文件位置**:
- 路径: `data/loro/<pool_id>/snapshot.loro`

---

## 需求：读取层 - SQLite 缓存

系统应维护 SQLite 缓存以优化读取查询。

### 场景：所有读取来自 SQLite

- **前置条件**: 用户请求卡片列表
- **操作**: 执行查询
- **预期结果**: 数据应从 SQLite 读取
- **并且**: 读取时不应访问 Loro 文档

**理由**:
- SQLite 提供快速索引查询
- 避免为每次读取反序列化 Loro 文档
- 支持复杂查询（过滤、排序、分页）

### 场景：SQLite schema 设计

- **前置条件**: 系统需要定义缓存层的表结构
- **操作**: 建立卡片、池及绑定关系的表
- **预期结果**: 支持常用查询并具备索引
- **并且**: schema 可被重复初始化

**卡片表**:


**卡片-池绑定表**:


**池表**:


### 场景：查询优化示例

- **前置条件**: 需要验证常用查询的可读性与索引使用
- **操作**: 列出典型查询语句
- **预期结果**: 查询语句覆盖列表、搜索与计数
- **并且**: 可用于性能调优

**示例 1：获取当前池中的所有卡片**


**示例 2：按标题搜索卡片**


**示例 3：统计池中的卡片数量**


---

## 需求：订阅驱动的同步

系统应使用 Loro 文档订阅自动将变更从写入层传播到读取层。

### 场景：卡片更新触发 SQLite 更新

- **前置条件**: Card Loro 文档被修改
- **操作**: 调用 Card.commit()
- **预期结果**: 应触发订阅回调
- **并且**: cards 表应被更新

### 场景：池更新触发 SQLite 更新

- **前置条件**: Pool Loro 文档被修改
- **操作**: 调用 Pool.commit()
- **预期结果**: 应触发订阅回调
- **并且**: card_pool_bindings 表应被更新
- **并且**: 更新应是幂等的

---

## 需求：数据一致性保证

系统应在 Loro 和 SQLite 层之间维护最终一致性。

### 场景：SQLite 最终反映 Loro 状态

- **前置条件**: Loro 文档被修改
- **操作**: 订阅回调完成
- **预期结果**: SQLite 应反映与 Loro 相同的数据
- **并且**: 任何后续读取应看到更新的数据

### 场景：处理订阅回调失败

- **前置条件**: Loro 文档被修改
- **操作**: 订阅回调失败
- **预期结果**: 错误应被记录
- **并且**: 系统应重试更新
- **并且**: Loro 应保持为数据源

---

## 需求：从 Loro 重建 SQLite

系统应支持从 Loro 文档重建整个 SQLite 缓存。

### 场景：损坏时重建 SQLite

- **前置条件**: SQLite 数据库损坏
- **操作**: 系统检测到损坏
- **预期结果**: 系统应删除 SQLite 数据库
- **并且**: 系统应从所有 Loro 文档重建
- **并且**: 所有数据应被恢复

---

## 优化策略

### 场景：写性能 - Loro

- **前置条件**: 高频写入导致响应延迟上升
- **操作**: 引入缓存与延迟持久化策略
- **预期结果**: 写入延迟保持可控
- **并且**: 不影响最终一致性

**优化**:
- **内存缓存**: 将频繁访问的 Loro 文档保存在内存中
- **延迟持久化**: 批量写入磁盘
- **增量快照**: 仅保存变更的文档

### 场景：读性能 - SQLite

- **前置条件**: 读取查询成为性能瓶颈
- **操作**: 配置 SQLite 并优化索引
- **预期结果**: 读取延迟降低
- **并且**: 读写并发能力提升

**优化**:
- **索引**: 在频繁查询的列上创建索引
- **查询规划**: 使用 EXPLAIN QUERY PLAN 优化查询
- **连接池**: 复用 SQLite 连接
- **WAL 模式**: 启用预写日志以提高并发性

---

## 补充说明

**设计模式**:
- **CQRS（命令查询职责分离）**: 分离写入和读取模型
- **观察者模式**: 订阅驱动更新
- **旁路缓存模式**: SQLite 作为 Loro 的缓存

**权衡**:
- **优点**: 无冲突同步、快速读取、最终一致性
- **缺点**: 最终一致性（非即时）、存储开销（两份副本）

---

## 相关文档

**架构规格**:
- [./card_store.md](./card_store.md) - CardStore 实现
- [./pool_store.md](./pool_store.md) - PoolStore 实现
- [./sqlite_cache.md](./sqlite_cache.md) - SQLite 缓存细节
- [./loro_integration.md](./loro_integration.md) - Loro 集成
- [../sync/subscription.md](../sync/subscription.md) - 订阅机制

**领域规格**:
- [../../domain/card.md](../../domain/card.md) - 卡片领域模型
- [../../domain/pool.md](../../domain/pool.md) - 池领域模型

**架构决策记录**:
- ADR-0002: 双层架构 - 读写分离设计决策
- ADR-0003: Loro CRDT - CRDT 选择理由

---

## 测试覆盖

**测试文件**: `rust/tests/dual_layer_feature_test.rs`

**单元测试**:
- `test_write_to_loro_updates_sqlite()` - 写入传播
- `test_read_from_sqlite_not_loro()` - 从缓存读取
- `test_subscription_callback_updates_sqlite()` - 订阅机制
- `test_rebuild_sqlite_from_loro()` - 重建功能
- `test_eventual_consistency()` - 一致性保证
- `test_loro_document_cache()` - 文档缓存
- `test_sqlite_configuration()` - SQLite 配置
- `test_retry_mechanism()` - 重试机制
- `test_transaction_atomicity()` - 事务原子性

**功能测试**:
- `test_end_to_end_write_read_flow()` - 端到端写读流程
- `test_sqlite_corruption_recovery()` - SQLite 损坏恢复
- `test_concurrent_writes()` - 并发写入

**验收标准**:
- [x] 所有单元测试通过
- [x] 功能测试通过
- [x] 代码审查通过
