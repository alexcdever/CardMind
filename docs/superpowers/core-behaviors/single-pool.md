# 单池模型行为指南

## 🎯 核心概念

CardMind采用"一个设备，一个笔记空间"的设计理念。每个设备在同一时间只能属于一个笔记空间，这样确保你的个人笔记保持一致性和私密性。

## 📋 核心行为

### 加入第一个笔记空间
当用户首次使用CardMind时：

**正常情况下**：
- 用户可以选择"创建新空间"或"加入现有空间"
- 输入正确的空间密码后，设备自动加入该空间
- 系统立即开始同步该空间的所有笔记
- 用户创建的每张新笔记都会自动属于这个空间

**为什么会这样设计**：
这样设计是为了避免混乱 - 想象一下，如果一个人的笔记分散在多个空间，找东西会变得很困难。一个空间让一切井井有条。

### 拒绝加入多个空间
如果用户已经加入了一个空间，再尝试加入另一个时：

**系统的友好响应**：
- 不会粗暴地报错，而是温和地提示："您已经加入了笔记空间'工作笔记'"
- 提供两个选择："留在当前空间"或"切换到新空间"
- 如果选择切换，会先安全退出当前空间，再加入新空间

**数据安全保障**：
- 切换空间前，系统会询问是否备份当前数据
- 所有数据都保存在本地，不会丢失
- 随时可以切换回之前的空间

### 离开笔记空间
当用户选择"退出当前空间"时：

**完整的数据清理**：
- 所有该空间的笔记从设备移除（只是本地移除）
- 停止与该空间的同步
- 设备回到"未加入空间"状态

**重要提醒**：
- 这只是从当前设备移除，不影响其他设备
- 如果再次加入同一个空间，所有数据都会重新同步回来
- 建议用户在退出前做好重要数据的导出

## 💡 实现建议

### 数据模型设计
```rust
// 设备配置 - 简化版
struct DeviceConfig {
    current_space: Option<String>,  // 当前笔记空间ID
    space_password_hash: Option<String>,  // 空间密码（加密存储）
    last_sync_time: Option<DateTime>,     // 最后同步时间
}

// 笔记空间信息
struct NoteSpace {
    id: String,                    // 空间唯一ID
    name: String,                  // 空间名称（用户可见）
    created_at: DateTime,          // 创建时间
    card_count: u32,               // 笔记数量
}
```

### 关键业务逻辑
```rust
impl DeviceConfig {
    // 加入笔记空间
    fn join_space(&mut self, space_id: String, password: String) -> Result<(), String> {
        // 检查是否已经加入了空间
        if self.current_space.is_some() {
            return Err("您已经加入了笔记空间，请先退出当前空间".to_string());
        }
        
        // 验证密码（这里应该有密码验证逻辑）
        if !verify_password(&space_id, &password) {
            return Err("密码错误，请检查后重试".to_string());
        }
        
        // 保存空间信息
        self.current_space = Some(space_id);
        self.space_password_hash = Some(hash_password(password));
        
        Ok(())
    }
    
    // 退出当前空间
    fn leave_current_space(&mut self) -> Result<(), String> {
        // 检查是否已加入空间
        if self.current_space.is_none() {
            return Err("您当前没有加入任何笔记空间".to_string());
        }
        
        // 清理空间相关数据
        self.current_space = None;
        self.space_password_hash = None;
        self.last_sync_time = None;
        
        // 这里应该触发清理本地数据的逻辑
        clear_local_space_data();
        
        Ok(())
    }
}
```

### 用户界面建议

**加入空间对话框**：
```
┌─────────────────────────────────────┐
│ 加入笔记空间                        │
├─────────────────────────────────────┤
│ 空间ID: [输入框]                    │
│ 密  码: [密码框]                    │
│                                     │
│ [加入空间] [取消]                   │
└─────────────────────────────────────┘
```

**错误处理示例**：
```
❌ 错误："SHALL_VIOLATION"
✅ 友好："您已经加入了'工作笔记'空间，
         是否切换到新空间？当前数据会被安全保存。"
```

## 🧪 测试场景

### 正常流程测试
1. **首次加入空间**：设备未加入任何空间 → 成功加入 → 验证数据同步
2. **创建笔记**：加入空间后 → 创建新笔记 → 验证自动归属
3. **退出空间**：有空间时退出 → 验证数据清理 → 验证可以重新加入

### 边界情况测试
1. **重复加入**：已加入空间 → 尝试加入另一个 → 验证被拒绝且友好提示
2. **无效密码**：加入空间时 → 输入错误密码 → 验证密码验证失败
3. **退出无空间**：未加入空间时 → 尝试退出 → 验证友好错误处理

## 🔗 相关行为

- **[笔记创建行为](card-creation.md)** - 如何在空间中创建笔记
- **[同步行为](sync-behavior.md)** - 空间数据如何同步
- **[密码安全行为](password-security.md)** - 空间密码如何保护

## 💬 设计思考

**为什么坚持单池模型？**

1. **用户体验简化**：用户不需要思考"这个笔记放在哪个空间？"
2. **数据一致性**：避免重复笔记和同步冲突
3. **隐私安全**：确保个人笔记不会意外同步到工作空间
4. **技术简化**：降低同步复杂度和错误概率

**潜在的扩展考虑**：
虽然现在是严格的单池模型，但设计时预留了`current_space`字段（而不是简单的`has_space`布尔值），为未来可能的"空间切换"功能留下空间。即使将来支持多空间，也会是"一次只能用一个"的模式，而不是"同时使用多个"。