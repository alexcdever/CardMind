# CardMind 技术栈文档

## 1. 整体架构

### 1.1 前后端分离架构
- **设计模式**：前后端完全分离，通过flutter_rust_bridge进行通信
- **前端**：负责UI渲染和网络权限申请
- **后端**：负责核心业务逻辑，包括数据存储、同步、设备组网和通信等

### 1.2 协同网络架构
- **核心技术**：基于Loro（CRDT协议）和libp2p（P2P网络协议）
- **分布式设计**：去中心化架构，无中心化服务器依赖
- **服务发现**：基于libp2p的mDNS集成，实现设备自动发现

## 2. 前端技术栈

| 技术/框架 | 版本/说明 | 用途 |
|-----------|-----------|------|
| Flutter | 最新稳定版 | 跨平台UI框架，负责应用界面渲染 |
| flutter_rust_bridge | 最新稳定版 | 前后端通信桥梁，实现Flutter与Rust的高效通信 |
| 网络权限管理 | Flutter内置 | 申请和管理设备网络相关权限 |

## 3. 后端技术栈

| 技术/语言 | 版本/说明 | 用途 |
|-----------|-----------|------|
| Rust | 最新稳定版 | 后端开发语言，负责核心业务逻辑 |
| Loro | 最新稳定版 | CRDT库，实现分布式数据无冲突同步 |
| libp2p | 最新稳定版 | P2P网络协议栈，实现设备组网、通信和服务发现 |
| sea-orm | 最新稳定版 | Rust ORM框架，简化SQLite数据库操作 |
| rusqlite | 最新稳定版 | SQLite数据库驱动，用于数据持久化 |

## 4. 数据存储与持久化

| 技术/组件 | 版本/说明 | 用途 |
|-----------|-----------|------|
| SQLite | 最新稳定版 | 本地数据库，用于存储卡片、协作网络和设备信息 |
| LoroDoc | 内置 | CRDT文档，每个卡片和协作网络对应一个LoroDoc对象 |
| UUID v7 | 标准实现 | 分布式ID生成算法，用于生成卡片ID、网络ID和设备ID |

### 4.1 数据存储设计
- **SQLite表设计**：参考卡片和协作网络属性建表
- **LoroDoc存储**：额外添加字段存储LoroDoc二进制数据
- **读写分离**：
  - 写操作：Flutter → Rust → Loro → SQLite
  - 读操作：Flutter直接从SQLite读取

## 5. 通信与网络

| 技术/协议 | 版本/说明 | 用途 |
|-----------|-----------|------|
| libp2p | 最新稳定版 | 替代WebRTC和传统信令服务，实现设备间直接通信 |
| mDNS | libp2p集成 | 本地网络设备发现，实现设备自动组网 |
| flutter_rust_bridge | 最新稳定版 | 前后端进程间通信，实现高效数据传输 |

### 5.1 网络通信流程
- **设备发现**：通过libp2p的mDNS协议实现本地网络设备发现
- **连接建立**：设备直接通过libp2p建立P2P连接，无需传统信令服务器
- **数据同步**：基于Loro的CRDT算法实现无冲突数据同步
- **NAT穿透**：利用libp2p内置的NAT穿透功能，支持复杂网络环境

## 6. 开发工具与依赖管理

| 工具/组件 | 版本/说明 | 用途 |
|-----------|-----------|------|
| Cargo | Rust官方 | Rust依赖管理和构建工具 |
| pub | Flutter官方 | Flutter依赖管理工具 |
| flutter_rust_bridge_codegen | 最新稳定版 | 自动生成Flutter与Rust通信代码 |
| SQLite Studio | 可选 | SQLite数据库可视化管理工具 |

## 7. 平台支持

| 平台 | 支持情况 | 技术实现 |
|------|----------|----------|
| Windows | ✅ | Flutter + Rust |
| macOS | ✅ | Flutter + Rust |
| Linux | ✅ | Flutter + Rust |
| Android | ✅ | Flutter + Rust |
| iOS | ✅ | Flutter + Rust |

## 8. 技术选型理由

### 8.1 为什么选择Flutter + Rust
- **跨平台能力**：Flutter支持多平台开发，降低开发成本
- **性能优势**：Rust提供接近原生的性能，适合处理核心业务逻辑
- **内存安全**：Rust的所有权机制避免了内存泄漏等问题
- **生态成熟**：Flutter拥有丰富的UI组件和社区支持

### 8.2 为什么选择Loro
- **CRDT算法**：提供强最终一致性，支持离线操作
- **高效同步**：支持增量同步，减少网络传输
- **跨平台支持**：可在Rust和其他语言中使用
- **易用性**：提供简洁的API，便于集成

### 8.3 为什么选择libp2p
- **模块化设计**：支持多种传输协议和服务发现机制
- **去中心化**：无需传统信令服务器，降低部署成本
- **NAT穿透**：内置NAT穿透功能，支持复杂网络环境
- **安全可靠**：支持端到端加密，确保通信安全
- **替代方案**：同时替代WebRTC和传统信令服务，简化技术栈

### 8.4 为什么选择SQLite
- **轻量级**：嵌入到应用中，无需额外部署
- **高性能**：适合本地数据存储和快速查询
- **跨平台**：支持所有目标平台
- **成熟稳定**：经过长期验证，可靠性高

## 9. 技术栈演进方向

- **性能优化**：进一步优化数据同步和查询性能
- **安全性增强**：加强端到端加密和身份验证
- **扩展性设计**：支持更多P2P协议和传输方式
- **生态集成**：与更多开源工具和框架集成
- **测试覆盖**：完善单元测试和集成测试

## 10. 依赖管理策略

- **前端依赖**：通过pub管理，定期更新至稳定版
- **后端依赖**：通过Cargo管理，使用固定版本号确保构建稳定性
- **第三方库**：优先选择成熟、活跃维护的开源库
- **安全审计**：定期进行依赖安全审计，及时修复漏洞

---

**文档版本**：v1.0
**最后更新**：2025-12-19
**适用范围**：CardMind项目开发和维护