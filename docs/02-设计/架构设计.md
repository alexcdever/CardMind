# CardMind 架构设计文档

## 目录

1. [概述](#1-概述)
2. [核心技术概念](#2-核心技术概念)
   2.1 [网络认证与设备管理](#21-网络认证与设备管理)
   2.2 [Yjs CRDT 同步机制](#22-yjs-crdt-同步机制)
   2.3 [双数据源工作方式](#23-双数据源工作方式)
   2.4 [WebRTC 点对点通信](#24-webrtc-点对点通信)
3. [整体架构设计](#3-整体架构设计)
   3.1 [架构概览](#31-架构概览)
   3.2 [平台优先级与部署能力](#32-平台优先级与部署能力)
   3.3 [核心组件](#33-核心组件)
   3.4 [通信机制](#34-通信机制)
   3.5 [数据流向](#35-数据流向)
   3.6 [通信优先级策略](#36-通信优先级策略)
4. [前端架构设计](#4-前端架构设计)
   4.1 [前端核心架构](#41-前端核心架构)
   4.2 [跨平台适配](#42-跨平台适配)
   4.3 [前端数据存储](#43-前端数据存储)
   4.4 [前端实时同步](#44-前端实时同步)
   4.5 [移动端接入协作网络机制](#45-移动端接入协作网络机制)
5. [后端架构设计](#5-后端架构设计)
   5.1 [后端核心架构](#51-后端核心架构)
   5.2 [信令服务器设计](#52-信令服务器设计)
   5.3 [Yjs文档管理](#53-yjs文档管理)
   5.4 [数据持久化](#54-数据持久化)
   5.5 [后端服务共享架构](#55-后端服务共享架构)
6. [数据模型](#6-数据模型)
7. [关键流程](#7-关键流程)
8. [注意事项](#8-注意事项)

## 1. 概述

CardMind基于CRDT数据同步、WebRTC点对点通信和离线优先架构，实现多设备间的无缝数据协作。本文档介绍了CardMind的核心架构设计、技术概念和跨平台实现方案。

### 1.1 协作网络定义

**协作网络**是指由多个设备组成的、通过WebRTC和Yjs技术实现实时数据同步的分布式系统。在CardMind中，协作网络具有以下特征：

- **去中心化设计**：不依赖中央服务器进行数据同步和冲突解决
- **实时数据同步**：设备间的修改实时同步，延迟低
- **自动冲突解决**：利用Yjs的CRDT特性自动解决数据冲突
- **离线支持**：设备离线时仍可操作，上线后自动同步
- **跨平台兼容**：支持Web、Electron和React Native平台
- **安全通信**：所有通信默认加密，保护数据安全

### 1.2 协作网络运行方式

#### 1.2.1 网络生命周期

1. **网络创建**
   - 任何设备都可以生成唯一的网络ID
   - 生成Access Code，包含网络ID和连接信息
   - 初始化Yjs文档用于数据同步

2. **设备加入**
   - 新设备输入Access Code
   - 验证Access Code有效性
   - 建立WebRTC连接
   - 同步Yjs文档数据
   - 注册设备信息到网络

3. **数据同步**
   - 设备修改数据时，更新本地IndexedDB
   - Yjs自动将修改同步到其他设备
   - 其他设备接收修改并更新本地数据
   - 自动解决冲突，确保最终一致性

4. **设备离开**
   - 设备主动离开网络
   - 或网络检测到设备离线
   - 更新设备状态
   - 不影响其他设备继续协作

5. **网络销毁**
   - 当所有设备离开网络时，网络自动销毁
   - 或设备主动销毁网络
   - 清除相关数据和连接

#### 1.2.2 通信机制

1. **同一设备内**：使用BroadcastChannel或IPC通信
2. **同一局域网**：直接IP连接或本地WebSocket服务器
3. **跨网络**：通过云信令服务器和STUN/TURN服务器实现NAT穿透

#### 1.2.3 数据流向

- **写操作**：用户修改 → 更新IndexedDB → 更新Yjs文档 → 同步到其他设备
- **读操作**：优先从IndexedDB读取 → 必要时从Yjs同步
- **冲突解决**：基于Yjs的CRDT算法自动解决

#### 1.2.4 核心组件

1. **SyncService**：管理设备间的数据同步逻辑
2. **Yjs文档**：存储和同步卡片数据
3. **WebRTC连接**：实现设备间点对点通信
4. **IndexedDB**：本地数据持久化
5. **Access Code**：网络加入凭证

## 2. 核心技术概念

### 2.1 网络认证与设备管理

#### 2.1.1 网络ID生成机制
- **UUID v4**: 使用加密安全的随机UUID生成唯一网络标识符
- **可发现性**: 网络ID设计为易分享和识别的格式
- **生成权限**: 每个设备都可以生成网络ID，无主次设备之分
- **唯一性保证**: 使用加密随机数生成，确保全球唯一性

#### 2.1.2 设备ID与昵称管理
- **设备ID生成**: 结合设备指纹和随机UUID生成持久化设备标识
- **本地存储**: 设备ID使用IndexedDB本地持久化存储
- **设备昵称**: 用户友好的设备名称，默认使用设备类型+随机字符组合
- **个性化设置**: 支持用户自定义设备昵称
- **冲突处理**: 当多设备昵称相同时，自动添加后缀确保唯一性

#### 2.1.3 Access Code机制
- **编码算法**: 使用URL安全的Base64编码
- **数据结构**: 包含网络ID、WebRTC连接信息、时间戳和设备标识
- **设计原则**: 不保存Access Code，每次需要时重新生成

### 2.2 Yjs CRDT 同步机制

#### 2.2.1 CRDT 基本原理
- **CRDT**（Conflict-free Replicated Data Type）：无冲突复制数据类型
- **自动合并**：不同设备上的修改可以自动合并
- **强最终一致性**：所有设备最终会收敛到相同状态
- **无中心化**：不依赖中央服务器进行数据同步和冲突解决

#### 2.2.2 Yjs 特性
- **高性能**：即使在高延迟网络环境下也能保持良好性能
- **可扩展性**：支持任意数量的并发编辑者
- **版本历史**：维护操作历史，支持撤销/重做
- **空间效率**：使用delta压缩减少传输数据量
- **持久化**：支持多种持久化方式，包括IndexedDB

### 2.3 双数据源工作方式

#### 2.3.1 双数据源设计理念
- **业务数据存储**：使用IndexedDB存储业务数据，提供结构化查询能力
- **同步数据层**：使用Yjs作为同步层，负责多设备间的实时同步
- **双向同步**：维护两个数据源之间的一致性
- **本地优先**：优先使用本地数据提供快速响应

#### 2.3.2 数据流向
- **写操作**：用户修改 → 更新IndexedDB → 更新Yjs文档 → 同步到其他设备
- **读操作**：优先从IndexedDB读取 → 必要时从Yjs同步
- **冲突解决**：基于时间戳的冲突解决策略

### 2.4 WebRTC 点对点通信

#### 2.4.1 WebRTC 基本原理
- **点对点连接**：直接在浏览器之间建立连接，无需经过服务器中转
- **NAT穿透**：使用ICE/STUN/TURN协议解决NAT穿透问题
- **加密通信**：所有WebRTC通信默认加密

#### 2.4.2 y-webrtc 适配器
- **自动连接管理**：自动管理连接的建立、维护和断开
- **房间概念**：使用命名房间组织协作用户
- **意识协议**：跟踪在线用户状态和光标位置

## 3. 整体架构设计

### 3.1 架构概览

```
┌─────────────────────────────────────────────────────────────────┐
│                        客户端层                                   │
├─────────────┬─────────────┬─────────────┬──────────────────────┤
│   Web端     │  Electron   │ React Native│    其他平台          │
│(浏览器环境)  │(桌面环境)    │(移动环境)    │(TV/嵌入式等)        │
└──────┬──────┴──────┬──────┴──────┬──────┴──────┬─────────────────┘
       │             │             │             │
       └─────────────┼─────────────┼─────────────┼─────────────────┘
                     │             │             │
              ┌──────▼─────────────────────────────▼─────────────────┐
              │              通信适配层                               │
              │  ┌─────────────┬─────────────┬────────────────────┐  │
              │  │ 平台检测  │  连接策略   │   协议适配         │  │
              │  └─────────────┴─────────────┴────────────────────┘  │
              └──────────────────┬─────────────────────────────────┘
                                 │
              ┌──────────────────┼─────────────────────────────────┐
              │                  │                                 │
       ┌──────▼──────┐    ┌──────▼──────┐                  ┌──────▼──────┐
       │本地通信优先 │                  │云信令服务  │
       │BroadcastChan│                  │WebSocket   │
       │IPC(原生)    │                  │Serverless  │
       └──────┬──────┘    └──────┬──────┘                  └──────┬──────┘
              │                  │                                 │
              └──────────────────┼─────────────────────────────────┘
                                 │
              ┌──────────────────▼─────────────────────────────────┐
              │              WebRTC核心层                        │
              │  ┌─────────────┬─────────────┬────────────────────┐  │
              │  │ 连接管理   │  NAT穿透    │   数据通道         │  │
              │  │ 状态监控   │  ICE处理    │   加密传输         │  │
              │  └─────────────┴─────────────┴────────────────────┘  │
              └──────────────────┬─────────────────────────────────┘
                                 │
              ┌──────────────────▼─────────────────────────────────┐
              │              Yjs CRDT层                         │
              │  ┌─────────────┬─────────────┬────────────────────┐  │
              │  │ 文档同步   │ 冲突解决    │   状态管理         │  │
              │  │ 版本控制   │ 合并策略    │   持久化           │  │
              │  └─────────────┴─────────────┴────────────────────┘  │
              └──────────────────┬─────────────────────────────────┘
                                 │
              ┌──────────────────▼─────────────────────────────────┐
              │              数据存储层                         │
              │  ┌─────────────┬─────────────┬────────────────────┐  │
              │  │ IndexedDB  │ AsyncStorage│   SQLite         │  │
              │  │ (Web/桌面)  │ (RN)        │   (原生)         │  │
              │  └─────────────┴─────────────┴────────────────────┘  │
              └──────────────────────────────────────────────────┘
```

### 3.2 平台优先级与部署能力

| 平台类型 | 优先级 | 落地顺序 | 部署能力 | 主要角色 |
|---------|--------|----------|----------|----------|
| Electron (PC) | 最高 | 1 | 客户端+服务端 | 数据中心、信令服务、局域网同步中心 |
| React Native (移动端) | 中等 | 2 | 仅客户端 | 移动访问终端、依赖其他平台服务 |
| Web 平台 | 最低 | 3 | 客户端+服务端 | 跨网络信令服务、全球访问入口、前后端分离架构 |

> 详细的开发策略和部署策略请参考 [0301-技术栈文档.md](0301-技术栈文档.md)

### 3.3 核心组件

1. **SyncService**：管理设备间的数据同步逻辑
2. **Yjs文档**：存储和同步卡片数据
3. **WebRTC连接**：实现设备间点对点通信
4. **IndexedDB**：本地数据持久化
5. **Access Code**：网络加入凭证
6. **信令服务器**：处理WebRTC连接建立过程中的信令交换
7. **YjsDocumentManager**：管理服务端Yjs文档的持久化

### 3.4 通信机制

1. **同一设备内**：使用BroadcastChannel或IPC通信
2. **同一局域网**：直接IP连接或本地WebSocket服务器
3. **跨网络**：通过云信令服务器和STUN/TURN服务器实现NAT穿透

### 3.5 数据流向

- **写操作**：用户修改 → 更新IndexedDB → 更新Yjs文档 → 同步到其他设备
- **读操作**：优先从IndexedDB读取 → 必要时从Yjs同步
- **冲突解决**：基于Yjs的CRDT算法自动解决

## 4. 前端架构设计

### 4.1 前端核心架构

前端采用分层架构设计，主要包含以下层次：

1. **UI组件层**：React组件，负责用户界面渲染
2. **状态管理层**：Zustand状态管理，处理应用状态
3. **服务层**：业务逻辑封装，处理数据同步和存储
4. **数据访问层**：本地存储和远程同步的抽象
5. **适配层**：跨平台适配，处理不同平台的差异

### 4.2 跨平台适配

#### 4.2.1 Web平台适配
- **通信机制**: BroadcastChannel + WebSocket
- **存储方案**: IndexedDB（通过Dexie.js）
- **部署方式**: Web页面形式，支持浏览器访问

#### 4.2.2 Electron平台适配
- **通信机制**: IPC通信 + WebSocket
- **存储方案**: IndexedDB + Node.js fs模块
- **部署方式**: 桌面应用，内置完整的后端服务

#### 4.2.3 React Native平台适配
- **通信机制**: WebSocket + 原生事件桥
- **存储方案**: AsyncStorage + SQLite
- **部署方式**: 移动应用，依赖其他平台提供的后端服务

### 4.3 前端数据存储

- **业务数据**：使用Dexie.js管理IndexedDB，提供结构化查询能力
- **同步数据**：使用Yjs管理同步状态，确保多设备数据一致性
- **持久化**：使用y-indexeddb持久化Yjs文档，确保数据不丢失
- **索引优化**：为常用查询字段创建索引，提高查询性能

### 4.4 前端实时同步

- **双数据源设计**：
  - 业务数据存储：IndexedDB，提供快速查询
  - 同步数据层：Yjs，负责多设备实时同步
- **数据流向**：
  - 写操作：用户修改 → 更新IndexedDB → 更新Yjs文档 → 同步到其他设备
  - 读操作：优先从IndexedDB读取 → 必要时从Yjs同步
- **冲突解决**：基于Yjs的CRDT算法自动解决冲突

## 5. 后端架构设计

### 5.1 后端核心架构

后端采用模块化设计，主要包含以下核心模块：

1. **信令服务模块**：处理WebRTC连接建立过程中的信令交换
2. **Yjs文档管理模块**：管理服务端Yjs文档的创建、更新和销毁
3. **数据持久化模块**：使用LevelDB存储Yjs文档数据
4. **API服务模块**：提供RESTful API接口
5. **设备管理模块**：管理协作网络中的设备信息

### 5.2 信令服务器设计

#### 5.2.1 轻量级信令服务器

- **核心功能**：
  - WebSocket连接管理
  - 房间管理和消息广播
  - 设备发现和状态跟踪
  - WebRTC信令转发

- **部署方案**：
  - **Docker容器化**: 支持容器化部署
  - **Serverless**: 支持Vercel等Serverless平台
  - **本地部署**: 支持Electron/React Native内置信令服务

### 5.3 后端服务共享架构

#### 5.3.1 架构设计

```
┌─────────────────────────────────────────────────────────────────┐
│                       后端服务层                                 │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                     共享后端服务代码                        │  │
│  │  ┌─────────────┬─────────────┬────────────────────┐      │  │
│  │  │ 信令服务   │  Yjs文档管理 │   API服务          │      │  │
│  │  └─────────────┴─────────────┴────────────────────┘      │  │
│  └────────────────────────┬────────────────────────────────┘  │
│                           │                                    │
└───────────────────────────┼─────────────────────────────────────┘
                           │
              ┌─────────────▼─────────────┐
              │        部署适配层          │
              ├─────────────┬─────────────┤
              │ Electron   │   Web平台    │
              │ 子进程形式  │  容器/云部署  │
              └──────┬──────┴──────┬──────┘
                     │             │
       ┌─────────────▼──────┐ ┌────▼─────────────┐
       │  Electron客户端     │ │   Web客户端      │
       │ (桌面应用)         │ │ (浏览器)         │
       └────────────────────┘ └──────────────────┘
```

#### 5.3.1.1 子进程实现机制

##### 5.3.1.1.1 Electron子进程管理
```typescript
// Electron主进程中的子进程管理
import { spawn } from 'child_process';
import path from 'path';

class BackendProcessManager {
  private backendProcess: ChildProcess | null = null;

  async startBackend() {
    // 获取后端服务入口文件路径
    const backendPath = path.join(__dirname, '../backend/server.js');
    
    // 启动后端服务子进程
    this.backendProcess = spawn('node', [backendPath], {
      stdio: ['ignore', 'pipe', 'pipe', 'ipc'],
      env: {
        ...process.env,
        PORT: '3001', // 为Electron后端服务指定端口
        NODE_ENV: 'production'
      }
    });

    // 监听子进程输出和退出事件
    // ...

    // 等待后端服务启动完成
    await this.waitForBackendReady();
  }

  async stopBackend() {
    if (this.backendProcess) {
      this.backendProcess.kill();
      this.backendProcess = null;
    }
  }

  private async waitForBackendReady() {
    // 实现等待后端服务启动完成的逻辑
    // ...
  }
}
```

##### 5.3.1.1.2 进程间通信方案
- **推荐使用HTTP/WebSocket**：标准化、简单、无需修改后端代码
- **Electron IPC**：仅用于Electron内部组件通信
- **通信客户端**：封装统一的通信接口，屏蔽不同平台的通信差异

##### 5.3.1.1.3 优势
- **代码完全共享**：无需为Electron编写兼容性代码
- **独立运行环境**：后端服务不受Electron环境影响
- **简化部署适配层**：只需要处理子进程的启动、停止和通信
- **跨平台一致性**：Electron和Web平台使用相同的后端部署逻辑

#### 5.3.2 备选架构（Web后端为主）

```
┌─────────────────────────────────────────────────────────────────┐
│                       Web后端服务                               │
│  ┌─────────────┬─────────────┬────────────────────┐              │
│  │ 信令服务   │  Yjs文档管理 │   API服务          │              │
│  └─────────────┴─────────────┴────────────────────┘              │
└────────────────────────┬───────────────────────────────────────┘
                         │
              ┌──────────▼──────────┐
              │  服务适配层          │
              │  (Electron专用)      │
              └──────────┬──────────┘
                         │
       ┌─────────────────▼─────────────────┐
       │          Electron客户端           │
       │      (集成适配后的后端服务)        │
       └───────────────────────────────────┘
```

#### 5.3.3 代码共享实现策略
1. **模块化设计**：将后端服务拆分为独立模块，便于不同平台复用
2. **平台抽象层**：为不同平台提供统一的API接口，内部实现适配不同平台
3. **配置驱动**：通过配置文件控制服务的启动和行为，适应不同平台需求
4. **依赖管理**：使用统一的依赖管理工具，确保不同平台使用相同版本的依赖
5. **测试策略**：编写跨平台的测试用例，确保代码在不同平台上的一致性

### 3.6 通信优先级策略

#### 3.6.1 连接优先级（按速度和稳定性排序）
1. **同一设备内**（速度最快，延迟最低）
   - Web: BroadcastChannel
   - Electron: IPC通信
   - React Native: Native Event Bridge

2. **同一局域网**（速度较快，无网络成本）
   - 直接IP连接
   - 本地WebSocket服务器

3. **跨网络/互联网**（覆盖范围广，需要服务器）
   - 云信令服务器
   - STUN/TURN服务器协助NAT穿透
   - 完全P2P数据传输

#### 3.6.2 自动降级机制
```typescript
class ConnectionManager {
  async establishConnection(targetDevice: DeviceInfo): Promise<Connection> {
    // 1. 尝试同一设备内通信
    if (this.isSameDevice(targetDevice)) {
      return await this.tryIntraDeviceConnection();
    }
    
    // 2. 尝试局域网发现
    const localConnection = await this.tryLocalNetworkDiscovery();
    if (localConnection) {
      return localConnection;
    }
    
    // 3. 使用云信令服务
    return await this.establishCloudSignalingConnection();
  }
}
```

### 4.5 移动端接入协作网络机制

#### 4.5.1 同一局域网内
1. **设备连接**：
   - 手动输入PC端的IP地址

2. **连接建立**：
   - 移动端直接连接到PC端的服务
   - 使用WebRTC建立点对点连接
   - 数据直接在移动端和PC端之间传输

3. **数据同步**：
   - 通过Yjs CRDT算法实现数据同步
   - PC端作为数据中心，存储完整数据
   - 移动端可以只存储最近使用的数据

#### 4.5.2 跨网络
1. **信令服务接入**：
   - 移动端连接到web平台的信令服务
   - 或者连接到公网可访问的PC端服务

2. **设备发现**：
   - 通过信令服务发现网络中的其他设备
   - 信令服务维护网络成员列表

3. **连接建立**：
   - 通过信令服务交换WebRTC连接信息
   - 建立跨网络的点对点连接
   - 或者通过服务端中转数据

4. **数据同步**：
   - 通过Yjs CRDT算法实现数据同步
   - 服务端作为数据备份和中转中心
   - 支持增量同步，减少网络传输量

## 5. 后端架构设计

### 5.2 轻量级信令服务器

#### 5.2.1 核心功能
- WebSocket连接管理
- 房间管理和消息广播
- 设备发现和状态跟踪
- WebRTC信令转发

#### 5.2.2 部署方案
- **Docker容器化**: 支持容器化部署
- **Serverless**: 支持Vercel等Serverless平台
- **本地部署**: 支持Electron/React Native内置信令服务

## 6. 数据模型

### 6.1 核心数据实体

- **Card**：卡片实体
  - `id`：唯一标识符
  - `title`：卡片标题
  - `content`：卡片内容
  - `createdAt`：创建时间
  - `updatedAt`：更新时间
  - `isDeleted`：软删除标记
  - `lastModifiedBy`：最后修改设备ID

- **Network**：协作网络实体
  - `id`：网络唯一标识符（UUID）
  - `createdAt`：网络创建时间
  - `devices`：已加入设备列表
  - `lastActivity`：最后活动时间

- **Device**：设备实体
  - `id`：设备唯一标识符
  - `nickname`：设备昵称
  - `deviceType`：设备类型
  - `createdAt`：设备记录创建时间
  - `lastSeen`：最后在线时间

### 6.2 存储策略

#### 6.2.1 客户端存储
- **业务数据**：使用Dexie.js管理IndexedDB
- **同步数据**：使用Yjs管理同步状态
- **持久化**：使用y-indexeddb持久化Yjs文档
- **索引优化**：为常用查询字段创建索引

#### 6.2.2 服务端Yjs持久化

##### 6.2.2.1 设计理念
- **解决存储限制**：应对浏览器和移动端的存储容量限制
- **数据备份**：提供中心化的数据备份，防止设备丢失或损坏
- **跨网络同步**：改善跨网络设备的同步体验
- **分层存储**：客户端存储最近使用的数据，服务端存储完整数据
- **高性能存储**：使用LevelDB作为持久化存储，提供高效的读写性能和可靠的数据管理

##### 6.2.2.2 实现架构

CardMind使用**y-leveldb**插件将Yjs数据持久化到LevelDB数据库。y-leveldb是Yjs官方提供的LevelDB持久化插件，专为Yjs文档设计，提供高效的存储和检索功能。

```typescript
// 服务端Yjs文档管理器 - 使用y-leveldb
import * as Y from 'yjs';
import { leveldbPersistence } from 'y-leveldb';

class YjsDocumentManager {
  private documents: Map<string, Y.Doc> = new Map();
  private persistence: ReturnType<typeof leveldbPersistence>;

  constructor(storagePath: string) {
    // 初始化y-leveldb持久化
    this.persistence = leveldbPersistence(storagePath);
  }

  async getDocument(networkId: string): Promise<Y.Doc> {
    // 如果文档已存在，直接返回
    if (this.documents.has(networkId)) {
      return this.documents.get(networkId)!;
    }

    // 创建新的Yjs文档
    const doc = new Y.Doc();
    
    // 从LevelDB加载持久化的文档数据
    const persistedDoc = await this.persistence.getYDoc(networkId);
    
    // 将持久化数据应用到新文档
    Y.applyUpdate(doc, Y.encodeStateAsUpdate(persistedDoc));
    
    // 添加到文档映射
    this.documents.set(networkId, doc);
    
    // 监听文档变更，自动持久化到LevelDB
    doc.on('update', async (update) => {
      await this.persistence.storeUpdate(networkId, update);
    });

    return doc;
  }

  // 关闭文档并清理资源
  async closeDocument(networkId: string): Promise<void> {
    this.documents.delete(networkId);
    // LevelDB连接由y-leveldb管理，无需手动关闭
  }

  // 获取所有持久化的文档名称
  async getAllDocumentNames(): Promise<string[]> {
    return await this.persistence.getAllDocNames();
  }
}
```

##### 6.2.2.3 部署方案
- **基于共享后端代码**：
  - **Electron端**：内置Yjs文档管理器，使用y-leveldb将数据存储到LevelDB数据库
  - **Web平台后端**：部署到云服务器或容器中，使用y-leveldb将数据存储到LevelDB数据库
- **容器化部署**：支持Docker容器化，便于水平扩展和负载均衡
- **Serverless部署**：Web平台后端支持Serverless部署，降低运营成本
- **统一配置管理**：使用环境变量或配置文件统一管理不同部署环境的配置

##### 6.2.2.4 LevelDB集成方案

###### 6.2.2.4.1 依赖安装
```bash
# 安装y-leveldb和相关依赖
pnpm add y-leveldb level
```

###### 6.2.2.4.2 配置参数
| 参数 | 说明 | 默认值 |
|------|------|--------|
| `storagePath` | LevelDB数据存储路径 | `./yjs-storage` |
| `prefix` | 数据前缀，用于区分不同应用的数据 | 无 |
| `compression` | 是否启用数据压缩 | `true` |
| `cacheSize` | LevelDB缓存大小（MB） | 8 |

###### 6.2.2.4.3 WebSocket服务器集成
```typescript
// WebSocket服务器集成LevelDB持久化
import { createServer } from 'y-websocket';
import { leveldbPersistence } from 'y-leveldb';

const persistence = leveldbPersistence('./yjs-storage');

const server = createServer({
  // 绑定Yjs文档到LevelDB
  bindState: async (docName, ydoc) => {
    const persistedYdoc = await persistence.getYDoc(docName);
    Y.applyUpdate(ydoc, Y.encodeStateAsUpdate(persistedYdoc));
    ydoc.on('update', async (update) => {
      await persistence.storeUpdate(docName, update);
    });
  },
  // 当文档不再需要时清理资源
  destroyState: async (docName) => {
    // LevelDB数据会持久保存，不需要手动清理
  }
});

server.listen(1234);
```

###### 6.2.2.4.4 数据备份与恢复
```typescript
// 数据备份示例
import fs from 'fs-extra';
import path from 'path';

// 备份LevelDB数据目录
async function backupLevelDB(sourcePath: string, backupPath: string) {
  await fs.copy(sourcePath, backupPath);
}

// 恢复LevelDB数据目录
async function restoreLevelDB(backupPath: string, targetPath: string) {
  await fs.copy(backupPath, targetPath);
}
```

##### 6.2.2.5 LevelDB优势
- **高性能**：针对键值存储优化，读写性能优异
- **可靠性**：内置崩溃恢复机制，数据安全性高
- **可扩展性**：支持大规模数据存储，适合未来功能扩展
- **内置压缩**：减少存储占用，降低磁盘空间需求
- **良好的生态**：有成熟的Node.js库支持，社区活跃
- **与Yjs完美集成**：使用官方插件，稳定性和兼容性有保障

##### 6.2.2.6 数据同步策略
1. **客户端优先**：客户端先尝试从本地加载数据，同时从服务端同步最新数据
2. **增量同步**：只同步变更的数据，减少网络传输量
3. **按需加载**：客户端可以只加载最近使用的数据，历史数据从服务端按需获取
4. **自动合并**：使用Yjs CRDT算法自动合并冲突

##### 6.2.2.7 优势
- **高可用性**：无单点故障，服务端不可用时客户端仍可工作
- **低延迟**：数据直接在设备间传输，减少中间环节
- **隐私安全**：数据不经过第三方服务器，降低泄露风险
- **低成本**：信令服务器资源消耗小，运营成本低

##### 6.2.2.8 挑战与解决方案
| 挑战 | 解决方案 |
|------|----------|
| NAT穿透困难 | 集成STUN/TURN服务器协助NAT穿透 |
| 数据一致性 | 使用成熟的Yjs库实现自动冲突解决 |
| 设备管理复杂 | 设计清晰的设备管理API，提供统一的设备管理界面 |

## 7. 关键流程

### 7.1 网络认证流程
- 检查设备ID
- 网络状态检查
- Access Code输入/生成
- 网络加入
- 设备注册

### 7.2 应用启动流程
- 初始化IndexedDB
- 加载设备信息
- 加载网络配置
- 建立WebRTC连接
- 同步数据
- 监听变更

### 7.3 数据操作同步流程
- 本地操作
- 本地保存
- 同步标记
- 实时传播
- 远程应用
- 双向同步

## 8. 注意事项

### 8.1 数据一致性
- CRDT算法确保最终一致性
- 双数据源设计需要仔细处理同步冲突
- 离线操作可能导致合并冲突

### 8.2 网络连接限制
- WebRTC连接需要网络支持UDP流量
- 某些企业网络环境可能限制WebRTC连接
- NAT穿透在某些复杂网络环境下可能失败

### 8.3 性能考虑
- Yjs文档大小会影响同步性能
- 大量并发编辑可能导致性能下降
- IndexedDB查询需要合理设计索引

### 8.4 安全考虑
- Access Code需要安全生成和传输
- WebRTC连接默认加密，但仍需验证设备身份
- 本地数据存储需要加密保护