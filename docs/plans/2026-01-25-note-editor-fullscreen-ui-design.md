# 移动端全屏笔记编辑器 UI 设计规格

## 1. 概述

本文档定义移动端全屏笔记编辑器（NoteEditorFullscreen）的 UI 设计规格，基于 React UI 参考实现。

**设计原则**：
- 遵循移动端平台特定设计（非响应式）
- 提供沉浸式的全屏编辑体验
- 自动保存机制保障数据安全
- 简化功能，专注于标题和内容编辑

**参考文件**：
- React UI: `react_ui_reference/src/app/components/note-editor-fullscreen.tsx`
- OpenSpec 规格: `openspec/specs/features/card_list/note_editor_fullscreen.md`
- 数据模型: `rust/src/models/card.rs`

## 2. 组件结构

### 2.1 NoteEditorFullscreen 组件

```dart
class NoteEditorFullscreen extends StatefulWidget {
  final Card? card;              // null = 新建模式，非 null = 编辑模式
  final String currentDevice;    // 当前设备标识
  final bool isOpen;             // 是否打开编辑器
  final OnClose onClose;         // 关闭回调
  final OnSave onSave;           // 保存回调

  const NoteEditorFullscreen({
    this.card,
    required this.currentDevice,
    required this.isOpen,
    required this.onClose,
    required this.onSave,
  });
}

typedef OnClose = void Function();
typedef OnSave = void Function(Card card);
```

### 2.2 内部状态

```dart
class _NoteEditorFullscreenState extends State<NoteEditorFullscreen> {
  late TextEditingController _titleController;
  late TextEditingController _contentController;
  Timer? _autoSaveTimer;
  bool _hasUnsavedChanges = false;
  String _originalTitle = '';
  String _originalContent = '';
}
```

## 3. 视觉设计

### 3.1 布局结构

```
┌─────────────────────────────────────┐
│ [×]              自动保存  [完成]    │ ← 工具栏 (56px + SafeArea.top)
├─────────────────────────────────────┤
│                                     │
│  笔记标题 (Input)                    │ ← 标题输入框
│                                     │
│  ─────────────────────────────────  │
│                                     │
│  开始写笔记... (Textarea)            │ ← 内容输入框 (min-h: 60vh)
│                                     │
│                                     │
│                                     │
│  ─────────────────────────────────  │
│  创建时间: 2026/1/26 14:30:45       │ ← 元数据区域
│  更新时间: 2026/1/26 15:20:30       │
│  最后编辑设备: iPhone 15            │
│                                     │
└─────────────────────────────────────┘
```

### 3.2 工具栏设计

- **高度**: 56px + SafeArea.top
- **背景**: 白色（浅色模式）/ 深色（深色模式），95% 不透明度 + 背景模糊
- **底部边框**: 1px 分隔线

#### 左侧：关闭按钮
- **图标**: × (Close)
- **尺寸**: 44x44px 触摸区域
- **样式**: Ghost 按钮

#### 右侧：保存区域
- **自动保存提示**:
  - 文字: "自动保存"
  - 字体大小: 14px
  - 颜色: 次要文字颜色
- **完成按钮**:
  - 文字: "完成"
  - 图标: ✓ (Check)
  - 样式: 主要按钮（主题色背景）

### 3.3 编辑区域设计

#### 标题输入框
- **占位符**: "笔记标题"
- **字体大小**: 24px
- **字体粗细**: 粗体
- **边框**: 无
- **内边距**: 水平 16px
- **高度**: 自适应（单行）
- **焦点样式**: 无外环

#### 内容输入框
- **占位符**: "开始写笔记..."
- **字体大小**: 16px
- **字体粗细**: 常规
- **边框**: 无
- **内边距**: 水平 16px
- **最小高度**: 60vh
- **可调整大小**: 否（固定宽度）
- **焦点样式**: 无外环
- **多行**: 是

#### 元数据区域
- **位置**: 内容输入框下方
- **内边距**: 16px
- **顶部边框**: 1px 分隔线
- **字体大小**: 14px
- **颜色**: 次要文字颜色
- **内容**:
  - 创建时间: `创建时间: {date.toLocaleString('zh-CN')}`
  - 更新时间: `更新时间: {date.toLocaleString('zh-CN')}`
  - 最后编辑设备: `最后编辑设备: {deviceName}`

### 3.4 确认对话框设计

#### 未保存更改对话框
- **标题**: "有未保存的更改"
- **内容**: "是否保存更改？"
- **按钮**:
  - "保存并关闭"（主要按钮）
  - "放弃更改"（危险按钮）
  - "取消"（次要按钮）

#### 内容为空提示
- **类型**: Toast 提示
- **内容**: "内容不能为空"
- **位置**: 屏幕底部
- **持续时间**: 2 秒

## 4. 交互设计

### 4.1 打开编辑器

**触发条件**: isOpen = true

**执行流程**:
1. 检查 card 参数
2. 如果 card 不为 null（编辑模式）：
   - 加载 card.title 到标题输入框
   - 加载 card.content 到内容输入框
   - 保存原始值用于检测更改
3. 如果 card 为 null（新建模式）：
   - 标题和内容为空
4. 显示编辑器（全屏动画）

**动画**: 从底部滑入，时长 300ms

### 4.2 自动保存

**触发条件**: 标题或内容发生变化

**执行流程**:
1. 取消之前的自动保存定时器
2. 设置新的定时器（1 秒延迟）
3. 1 秒后执行保存：
   - 检查内容是否为空
   - 如果内容为空，不保存
   - 如果内容不为空：
     - 调用 onSave 回调
     - 更新原始值
     - 清除未保存更改标记

**防抖时间**: 1 秒

### 4.3 点击完成按钮

**触发条件**: 用户点击"完成"按钮

**执行流程**:
1. 取消自动保存定时器
2. 验证内容：
   - 如果内容为空（trim 后）：
     - 显示 Toast 提示"内容不能为空"
     - 保持在编辑器中
     - 结束流程
3. 如果内容不为空：
   - 处理标题：如果标题为空（trim 后），设置为"无标题笔记"
   - 调用 onSave 回调
   - 调用 onClose 回调
   - 关闭编辑器

### 4.4 点击关闭按钮

**触发条件**: 用户点击"×"按钮

**执行流程**:
1. 检查是否有未保存的更改：
   - 比较当前标题/内容与原始值
   - 检查自动保存定时器是否在运行（防抖期间）
2. 如果没有未保存的更改：
   - 直接调用 onClose 回调
   - 关闭编辑器
3. 如果有未保存的更改：
   - 显示确认对话框
   - 等待用户选择

### 4.5 确认对话框交互

**选项 1: 保存并关闭**
- 执行与"点击完成按钮"相同的流程
- 如果内容为空，显示 Toast 提示，不关闭对话框

**选项 2: 放弃更改**
- 直接调用 onClose 回调
- 关闭编辑器
- 不保存任何更改

**选项 3: 取消**
- 关闭确认对话框
- 返回编辑器继续编辑

### 4.6 新建模式 vs 编辑模式

#### 新建模式（card = null）
- 内容为空时可以直接关闭，不显示确认对话框
- 点击"完成"时如果内容为空，显示 Toast 提示
- 保存时创建新的 Card 对象

#### 编辑模式（card ≠ null）
- 内容为空时关闭会显示确认对话框
- 点击"完成"时如果内容为空，显示 Toast 提示
- 保存时更新现有 Card 对象

## 5. 状态管理

### 5.1 编辑器状态

```dart
class EditorState {
  final String title;
  final String content;
  final bool hasUnsavedChanges;
  final bool isAutoSaving;

  const EditorState({
    required this.title,
    required this.content,
    required this.hasUnsavedChanges,
    required this.isAutoSaving,
  });
}
```

### 5.2 状态更新

- **title**: 标题输入框内容变化时更新
- **content**: 内容输入框内容变化时更新
- **hasUnsavedChanges**: 内容变化或自动保存定时器运行时为 true
- **isAutoSaving**: 自动保存定时器运行时为 true

## 6. 边界情况

### 6.1 数据边界

| 场景 | 处理方式 |
|------|----------|
| 标题为空 | 保存时自动填充"无标题笔记" |
| 内容为空（新建模式） | 不创建笔记，直接关闭 |
| 内容为空（编辑模式） | 不允许保存，显示 Toast 提示 |
| 标题超长 | 允许输入，UI 自动换行 |
| 内容超长 | 允许输入，滚动显示 |
| card 为 null | 新建模式 |
| card 不为 null | 编辑模式 |

### 6.2 交互边界

| 场景 | 处理方式 |
|------|----------|
| 快速连续点击完成按钮 | 防抖处理，只执行一次保存 |
| 自动保存期间点击完成 | 取消自动保存定时器，立即保存 |
| 自动保存期间点击关闭 | 视为有未保存更改，显示确认对话框 |
| 确认对话框打开时点击外部 | 关闭对话框，返回编辑器 |
| 编辑器打开时按返回键 | 触发关闭按钮逻辑 |

### 6.3 性能边界

| 场景 | 约束 | 处理方式 |
|------|------|----------|
| 自动保存频率 | 最多每秒 1 次 | 使用 1 秒防抖 |
| 内容输入响应 | < 16ms | 使用原生输入框 |
| 打开/关闭动画 | 60fps | 使用硬件加速动画 |

## 7. 测试用例

### 7.1 单元测试（8 个）

#### EditorState 测试

**UT-001: 测试初始状态创建（新建模式）**
- **输入**: card = null
- **预期**: title = "", content = "", hasUnsavedChanges = false

**UT-002: 测试初始状态创建（编辑模式）**
- **输入**: card = Card(title: "测试", content: "内容")
- **预期**: title = "测试", content = "内容", hasUnsavedChanges = false

**UT-003: 测试空标题处理**
- **输入**: title = "  ", content = "内容"
- **预期**: 保存时 title = "无标题笔记"

**UT-004: 测试空内容检测（新建模式）**
- **输入**: card = null, content = "  "
- **预期**: 可以关闭，不创建笔记

**UT-005: 测试空内容检测（编辑模式）**
- **输入**: card ≠ null, content = "  "
- **预期**: 不允许保存，显示错误提示

**UT-006: 测试未保存更改检测**
- **输入**: 原始 content = "旧内容", 当前 content = "新内容"
- **预期**: hasUnsavedChanges = true

**UT-007: 测试自动保存防抖**
- **输入**: 连续输入 5 个字符
- **预期**: 只触发 1 次自动保存（最后一次输入后 1 秒）

**UT-008: 测试回调类型定义**
- **输入**: OnSave, OnClose 回调函数
- **预期**: 类型定义正确，可正确调用

### 7.2 Widget 测试（45 个）

#### 渲染测试（12 个）

**WT-001: 测试基本渲染（新建模式）**
- **输入**: card = null, isOpen = true
- **预期**: 正确渲染编辑器，标题和内容为空

**WT-002: 测试基本渲染（编辑模式）**
- **输入**: card = Card(title: "测试", content: "内容"), isOpen = true
- **预期**: 正确渲染编辑器，显示标题和内容

**WT-003: 测试工具栏渲染**
- **输入**: isOpen = true
- **预期**: 显示关闭按钮、"自动保存"文字、完成按钮

**WT-004: 测试标题输入框**
- **输入**: isOpen = true
- **预期**: 显示占位符"笔记标题"，字体 24px 粗体

**WT-005: 测试内容输入框**
- **输入**: isOpen = true
- **预期**: 显示占位符"开始写笔记..."，最小高度 60vh

**WT-006: 测试元数据渲染（编辑模式）**
- **输入**: card = Card(createdAt: 1234567890, updatedAt: 1234567900, lastEditDevice: "iPhone")
- **预期**: 显示创建时间、更新时间、最后编辑设备

**WT-007: 测试元数据渲染（新建模式）**
- **输入**: card = null
- **预期**: 不显示元数据区域

**WT-008: 测试工具栏高度**
- **输入**: SafeArea.top = 44
- **预期**: 工具栏高度 = 56 + 44 = 100px

**WT-009: 测试背景模糊效果**
- **输入**: isOpen = true
- **预期**: 工具栏背景有模糊效果

**WT-010: 测试全屏布局**
- **输入**: isOpen = true
- **预期**: 编辑器占据整个屏幕

**WT-011: 测试关闭状态**
- **输入**: isOpen = false
- **预期**: 不渲染编辑器

**WT-012: 测试时间格式**
- **输入**: createdAt = 1737878400000 (2026/1/26 14:00:00)
- **预期**: 显示 "2026/1/26 14:00:00"

#### 交互测试（20 个）

**WT-013: 测试输入标题**
- **操作**: 在标题输入框输入"测试标题"
- **预期**: 标题更新为"测试标题"

**WT-014: 测试输入内容**
- **操作**: 在内容输入框输入"测试内容"
- **预期**: 内容更新为"测试内容"

**WT-015: 测试点击完成按钮（有效内容）**
- **输入**: title = "标题", content = "内容"
- **操作**: 点击完成按钮
- **预期**: onSave 被调用，onClose 被调用

**WT-016: 测试点击完成按钮（空内容）**
- **输入**: title = "标题", content = ""
- **操作**: 点击完成按钮
- **预期**: 显示 Toast "内容不能为空"，不关闭编辑器

**WT-017: 测试点击关闭按钮（无更改）**
- **输入**: 无更改
- **操作**: 点击关闭按钮
- **预期**: onClose 被调用，不显示确认对话框

**WT-018: 测试点击关闭按钮（有更改）**
- **输入**: 修改了内容
- **操作**: 点击关闭按钮
- **预期**: 显示确认对话框

**WT-019: 测试确认对话框 - 保存并关闭**
- **输入**: 有未保存更改
- **操作**: 点击关闭按钮 → 选择"保存并关闭"
- **预期**: onSave 被调用，onClose 被调用

**WT-020: 测试确认对话框 - 放弃更改**
- **输入**: 有未保存更改
- **操作**: 点击关闭按钮 → 选择"放弃更改"
- **预期**: onClose 被调用，onSave 不被调用

**WT-021: 测试确认对话框 - 取消**
- **输入**: 有未保存更改
- **操作**: 点击关闭按钮 → 选择"取消"
- **预期**: 对话框关闭，返回编辑器

**WT-022: 测试自动保存触发**
- **操作**: 输入内容，等待 1 秒
- **预期**: onSave 被调用

**WT-023: 测试自动保存防抖**
- **操作**: 连续输入，间隔 < 1 秒
- **预期**: 只在最后一次输入后 1 秒触发保存

**WT-024: 测试完成按钮取消自动保存**
- **操作**: 输入内容，立即点击完成按钮
- **预期**: 立即保存，不等待 1 秒

**WT-025: 测试空标题自动填充**
- **输入**: title = "", content = "内容"
- **操作**: 点击完成按钮
- **预期**: 保存的 title = "无标题笔记"

**WT-026: 测试新建模式空内容关闭**
- **输入**: card = null, content = ""
- **操作**: 点击关闭按钮
- **预期**: 直接关闭，不显示确认对话框

**WT-027: 测试编辑模式空内容关闭**
- **输入**: card ≠ null, 删除所有内容
- **操作**: 点击关闭按钮
- **预期**: 显示确认对话框

**WT-028: 测试快速连续点击完成按钮**
- **操作**: 快速点击完成按钮 3 次
- **预期**: onSave 只被调用 1 次

**WT-029: 测试打开动画**
- **操作**: 设置 isOpen = true
- **预期**: 编辑器从底部滑入，时长 300ms

**WT-030: 测试关闭动画**
- **操作**: 点击关闭按钮（无更改）
- **预期**: 编辑器向底部滑出，时长 300ms

**WT-031: 测试返回键行为**
- **操作**: 按返回键
- **预期**: 触发关闭按钮逻辑

**WT-032: 测试确认对话框外部点击**
- **操作**: 显示确认对话框，点击外部
- **预期**: 对话框关闭，返回编辑器

#### 边界测试（13 个）

**WT-033: 测试超长标题**
- **输入**: title = "A" * 1000
- **预期**: 正常显示，自动换行

**WT-034: 测试超长内容**
- **输入**: content = "A" * 10000
- **预期**: 正常显示，可滚动

**WT-035: 测试标题只有空格**
- **输入**: title = "   ", content = "内容"
- **预期**: 保存时 title = "无标题笔记"

**WT-036: 测试内容只有空格（新建模式）**
- **输入**: card = null, content = "   "
- **预期**: 可以关闭，不创建笔记

**WT-037: 测试内容只有空格（编辑模式）**
- **输入**: card ≠ null, content = "   "
- **预期**: 点击完成显示 Toast 提示

**WT-038: 测试内容只有换行符**
- **输入**: content = "\n\n\n"
- **预期**: 视为空内容

**WT-039: 测试 card 为 null**
- **输入**: card = null
- **预期**: 新建模式，标题和内容为空

**WT-040: 测试 card 不为 null**
- **输入**: card = Card(...)
- **预期**: 编辑模式，加载现有数据

**WT-041: 测试无 SafeArea**
- **输入**: SafeArea.top = 0
- **预期**: 工具栏高度 = 56px

**WT-042: 测试有 SafeArea**
- **输入**: SafeArea.top = 44
- **预期**: 工具栏高度 = 100px

**WT-043: 测试自动保存期间关闭**
- **操作**: 输入内容，立即点击关闭按钮（< 1 秒）
- **预期**: 显示确认对话框

**WT-044: 测试确认对话框保存空内容**
- **输入**: 删除所有内容
- **操作**: 点击关闭 → 选择"保存并关闭"
- **预期**: 显示 Toast 提示，不关闭对话框

**WT-045: 测试元数据缺失字段**
- **输入**: card.lastEditDevice = null
- **预期**: 不显示"最后编辑设备"行

## 8. 实现注意事项

### 8.1 性能优化

- 使用 `TextEditingController` 管理输入框状态
- 自动保存使用 `Timer` 实现防抖
- 避免不必要的 Widget 重建

### 8.2 状态管理

- 使用 `StatefulWidget` 管理编辑器状态
- 监听输入框变化，触发自动保存
- 维护原始值用于检测更改

### 8.3 数据验证

- 保存前 trim 标题和内容
- 空标题自动填充"无标题笔记"
- 空内容不允许保存（编辑模式）

### 8.4 用户体验

- 全屏沉浸式编辑体验
- 自动保存减少数据丢失风险
- 确认对话框防止误操作
- Toast 提示清晰的错误信息

## 9. 设计决策记录

### 9.1 为什么移除标签功能？

**决策**: 不支持标签管理

**理由**:
- 简化编辑器功能，专注于核心的标题和内容编辑
- 与 note-card 设计保持一致（不显示标签）
- 减少 UI 复杂度，提升编辑体验

### 9.2 为什么使用自动保存？

**决策**: 自动保存（1 秒防抖）+ 完成按钮立即保存

**理由**:
- 减少数据丢失风险
- 用户无需手动保存，降低认知负担
- 防抖机制平衡保存频率和性能

### 9.3 为什么内容不能为空？

**决策**: 编辑模式下内容不能为空

**理由**:
- 笔记的核心是内容，空内容没有意义
- 防止误操作删除所有内容
- 新建模式下空内容可以关闭（未创建笔记）

### 9.4 为什么需要确认对话框？

**决策**: 有未保存更改时显示确认对话框

**理由**:
- 防止误操作丢失数据
- 自动保存有 1 秒延迟，可能存在未保存的更改
- 给用户明确的选择权

### 9.5 为什么使用 60vh 最小高度？

**决策**: 内容输入框最小高度 60vh

**理由**:
- 与 React UI 保持一致
- 提供足够的编辑空间
- 避免频繁滚动

## 10. 后续工作

1. **实现阶段**:
   - 根据本规格实现 NoteEditorFullscreen 组件
   - 实现自动保存逻辑
   - 实现确认对话框
   - 编写单元测试和 Widget 测试

2. **集成阶段**:
   - 集成到笔记列表页面
   - 连接 Rust 数据模型
   - 实现保存和同步逻辑

3. **优化阶段**:
   - 性能优化
   - 用户体验优化
   - 多语言支持

## 11. 参考资料

- React UI 参考: `react_ui_reference/src/app/components/note-editor-fullscreen.tsx`
- 数据模型: `rust/src/models/card.rs`
- Flutter TextField: https://api.flutter.dev/flutter/material/TextField-class.html
- Material Design 文本输入: https://m3.material.io/components/text-fields/overview
