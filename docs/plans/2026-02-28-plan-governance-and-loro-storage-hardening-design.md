# CardMind 计划治理与 Loro 存储硬化设计（2026-02-28）

## 1. 背景与目标
- 当前状态：功能门禁已通过，但存在两类结构性缺口：
  - 文档执行规范不一致：多数 `*plan*.md` 未显式包含 TDD 蓝阶段（重构）。
  - 存储实现真实性不足：部分读写链路仍为内存替身实现。
- 目标：先统一计划文档治理，再将存储链路落到真实文件化 Loro + SQLite 读写分离实现。

## 2. 范围与优先级

### 2.1 Phase A（优先）计划治理全量补齐
- 范围：`docs/plans/*plan*.md` 全覆盖（包含历史计划文档）。
- 要求：统一加入 Red-Green-Blue-Commit 执行规则，明确“Blue 完成并复测通过后才能提交”。
- 守卫：新增/增强自动化校验，缺失 Blue 规则即门禁失败。

### 2.2 Phase B（次优）真实存储链路替换
- 范围：卡片域与池元数据域的写入、加载、投影与查询。
- 要求：Loro 写真源 + SQLite 读模型，移除内存替身作为主实现。

## 3. 存储架构硬约束

### 3.1 实体与 LoroDoc 映射
- 一张卡片笔记对应一个 `LoroDoc`。
- 一个数据池元数据实体对应一个 `LoroDoc`。

### 3.2 路径与文件布局
- 统一路径：`data/loro/{card-note|pool-meta}/{uuidv7}/{snapshot|update}`。
- 示例：
  - `data/loro/card-note/019.../snapshot`
  - `data/loro/card-note/019.../update`
  - `data/loro/pool-meta/019.../snapshot`
  - `data/loro/pool-meta/019.../update`

### 3.3 文件语义
- `snapshot`：当前文档快照文件。
- `update`：单文件增量更新日志，采用追加写。

### 3.4 生命周期规则
- 创建规则：`LoroDoc` 实例创建时，必须同时创建 `snapshot` 与 `update` 文件。
- 加载规则：每次从文件加载前先检查 `update` 大小：
  - 若 `update > 4MB`：
    1) 将 `update` 合并进 `snapshot`；
    2) 从合并后的 `snapshot` 读取文档；
    3) 清空 `update` 文件。
  - 若 `update <= 4MB`：按 `snapshot + update` 常规恢复。
- 更新规则：文档变更后追加写入同一个 `update` 文件。

## 4. 读写分离与数据流
- 写侧：所有业务变更先写 `LoroDoc`（真源）。
- 读侧：SQLite 承担复杂查询（列表、筛选、搜索、排序）。
- 投影：Loro 变更事件驱动 SQLite 增量更新。
- 同步：FRB/Rust/iroh 同步成功后回写 Loro，再触发读侧投影。

## 5. 执行策略

### 5.1 Phase A：计划治理
- 批量回补全部 `*plan*.md` 的 R/G/B 规则区块。
- 增加计划文档守卫测试，检查：
  - 是否包含 Red/Green/Blue 三阶段定义；
  - 是否声明 Blue 后才能 Commit。

### 5.2 Phase B：存储替换
- 先卡片域，后池元数据域。
- 每个域按 TDD 小步替换：
  - Red：新增失败测试（真实文件读写、阈值合并、投影一致性）。
  - Green：最小真实实现通过测试。
  - Blue：重构目录与接口，不改行为，复测通过。

### 5.3 Phase C：联调门禁
- 必跑：`flutter analyze`、`flutter test`、治理守卫、交互守卫、fractal 文档校验。
- 验证点：同步异常不阻断本地写入，阈值合并后读写与投影一致。

## 6. 风险与缓解
- 风险：阈值合并时机导致投影漏更新。
  - 缓解：合并后强制触发一次投影刷新测试。
- 风险：历史 `*plan*.md` 风格不一，批量改动易漏。
  - 缓解：先守卫定义，再批量改，最后全量扫描。
- 风险：目录/文件初始化竞态。
  - 缓解：创建操作幂等化，存在即校验，不重复破坏。

## 7. 验收标准
- 所有 `docs/plans/*plan*.md` 均含 R/G/B 规则并通过守卫。
- 卡片与池元数据主链路不再依赖内存替身。
- Loro 文件路径与阈值合并规则按本设计落地并有自动化测试覆盖。
- 全门禁通过。
