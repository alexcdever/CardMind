# ADR-0002: 采用双层架构（源数据层 + 查询缓存层）

**Status**: Accepted
**Date**: 2024-12-31
**Deciders**: CardMind Team

---

## Context

在设计 CardMind 的数据层时，需要平衡两个核心需求：
1. **分布式同步**：支持多设备 P2P 同步，离线编辑，自动冲突解决
2. **查询性能**：快速查询、索引优化、全文搜索

---

## Decision

采用**双层架构**：

```
┌─────────────────────────────────────────┐
│           应用层 (Flutter)              │
└─────────────────┬───────────────────────┘
                  │
         ┌────────┴─────────┐
         │                  │
         ▼                  ▼
┌─────────────────┐  ┌─────────────────┐
│  源数据层 (写)   │  │ 查询缓存层 (读)  │
│   Loro CRDT     │──│    SQLite       │
└─────────────────┘  └─────────────────┘
         │                  ▲
         │                  │
         └──────订阅────────┘
```

**核心机制**：
- 所有写操作 → Loro CRDT（真理源）
- 所有读操作 → SQLite（查询缓存）
- 订阅驱动更新：Loro commit → 触发回调 → SQLite 更新

---

## Technical Details

### 源数据层 (Loro CRDT)

**职责**：
- 接收所有写操作
- 保证数据一致性
- 支持分布式编辑
- 自动冲突解决 (CRDT)
- 文件持久化
- 触发数据变更通知

### 查询缓存层 (SQLite)

**职责**：
- 响应所有查询请求
- 提供快速查询
- 索引优化
- 全文搜索 (Phase 3)
- 聚合统计

**约束**：
- 应用层不可直接写入
- 数据来源仅限订阅更新
- Schema 变更时可删除重建

---

## Consequences

### Advantages

| 维度 | 纯 CRDT | 纯 SQL | 双层架构 |
|------|---------|--------|---------|
| 分布式同步 | ✓ 自动 | ✗ 复杂 | ✓ 由 CRDT 提供 |
| 快速查询 | ✗ 慢 | ✓ 快 | ✓ 由 SQLite 提供 |
| 冲突解决 | ✓ CRDT | ✗ 手动 | ✓ 由 CRDT 提供 |
| 全文搜索 | ✗ 无 | ✓ FTS5 | ✓ 由 SQLite 提供 |
| 维护成本 | 低 | 低 | 中 (需同步) |

### Trade-offs

**代价**：
- 需要维护订阅同步机制
- 数据存储占用略高（两份数据）
- Schema 变更需要同时考虑两层

**收益**：
- 充分利用 CRDT 和关系数据库的优势
- 开发体验好（SQL 查询熟悉）
- 扩展性强（缓存层可独立优化）

**结论**：代价可控，收益显著，适合 CardMind 的业务场景。

---

## Architecture Constraints

### 强制约束 (MUST)

1. 所有写操作必须通过源数据层（禁止直接写入缓存层）
2. 缓存层仅通过订阅更新（禁止应用层直接修改缓存）
3. 源数据层修改后必须提交（调用 `commit()` 触发订阅）
4. 缓存层可损坏重建（备份策略仅需备份源数据层）

### 建议约束 (SHOULD)

1. 查询优先使用缓存层（避免从源数据层遍历数据）
2. 批量操作使用事务（保证订阅更新的原子性）
3. 定期校验一致性（检测缓存层与源数据层的同步状态）

### 禁止操作 (MUST NOT)

1. 禁止绕过源数据层直接写缓存（破坏单向数据流）
2. 禁止在订阅回调中修改源数据层（避免循环依赖）
3. 禁止假设缓存层永久有效（可能损坏或重建）

---

## Alternatives Considered

| 方案 | 优点 | 缺点 | 结论 |
|------|------|------|------|
| **纯 CRDT** | 架构简单，无需同步 | 查询性能差，无法索引 | ❌ 放弃 |
| **纯 SQL** | 查询快速，熟悉度高 | 分布式同步复杂，冲突处理难 | ❌ 放弃 |
| **双向同步** | 灵活 | 冲突复杂，一致性难保证 | ❌ 放弃 |
| **单向数据流** | 一致性强，易于调试 | 需严格遵守契约 | ✅ 采用 |
| **双层架构** | 两全其美 | 维护成本 | ✅ 采用 |

---

## Implementation

### 订阅驱动更新流程

```
1. 用户操作 → 修改 Loro
2. 调用 commit() → 标记变更完成
3. 触发订阅回调 → 通知所有订阅者
4. 解析变更事件 → 执行 SQLite 更新
5. UI 刷新 → 查询 SQLite 获取最新数据
```

### 订阅保证

- **原子性**：订阅回调在同一事务内执行
- **一致性**：缓存更新失败不影响源数据层
- **顺序性**：订阅顺序与提交顺序一致

---

## Related Documents

- [System Design](../architecture/system_design.md) - 架构原则概述
- [Data Contract](../architecture/data_contract.md) - 数据契约定义
- [Sync Mechanism](../architecture/sync_mechanism.md) - 同步机制设计
- [Single Pool Model ADR](./0001-single-pool-ownership.md) - 单池模型决策

---

**最后更新**: 2026-01-15
**版本**: 1.0.0
