# ADR-0001：单池所有权模型

**状态**：已接受
**日期**：2026-01-09
**决策者**：@alexc

---

## 背景

CardMind 是为拥有多个设备的个人用户设计的笔记应用。核心特性包括：

- 跨设备的个人笔记（手机、平板、电脑）
- P2P 去中心化同步，无需中央服务器
- 离线优先，数据完全自主拥有

### 遇到的问题

在早期设计中，我们允许卡片同时属于多个数据池，设备也可以加入多个池：

```rust
Card {
    id: String,
    pool_ids: Vec<String>,  // 卡片可以属于多个池
}

DeviceConfig {
    joined_pools: Vec<String>,
    resident_pools: Vec<String>,
}
```

这个设计带来了三个严重问题：

**1. 删除操作无法正确传播**

当设备 A 从池中删除一张卡片时，只加入了该池的设备 B 永远收不到删除事件。原因是 SyncFilter 会过滤掉不属于设备已加入池的卡片，导致删除通知被屏蔽。

**2. 过度工程化**

CardMind 的核心场景是"个人笔记"，一个用户就是一个笔记空间。多池设计并不符合这个使用场景，反而增加了不必要的复杂度。

**3. 管理复杂性**

需要处理池关系、池切换、同步过滤器等复杂逻辑，给实现和维护都带来了负担。

---

## 决策

我们决定采用**单池所有权模型**：

- **每张卡片**恰好属于**一个池**
- **每个设备**最多只能加入**一个池**（符合个人笔记场景）
- 当设备创建新卡片时，卡片自动属于设备已加入的池

### 核心规则

**卡片池关联**

卡片在任何时刻都恰好属于一个池。当设备创建新卡片时，卡片自动归属于设备已加入的池。当卡片从池中删除时，删除事件会传播到该池的所有设备。

**设备池成员资格**

设备最多只能加入一个池。如果设备已经加入了一个池，尝试加入第二个池时系统会拒绝请求，并返回违反单池约束的错误。

---

## 考虑过的其他方案

**方案：设备可加入多个池**
拒绝原因：同步语义复杂，删除传播存在问题

**方案：卡片属于多个池**
拒绝原因：数据重复，同步逻辑复杂

**方案：完全没有池概念**
拒绝原因：无法支持用户间的隐私隔离

---

## 影响

### 优势

- **简单的心智模型**：一个用户 = 一个池，符合个人笔记的直觉
- **可靠的同步语义**：删除操作总是能正确传播到所有设备
- **降低实现复杂性**：减少了池管理、切换、过滤等复杂逻辑

### 缺点

- 用户无法将笔记分类到多个池中
- 在不同"上下文"之间切换需要离开当前池并加入新池

---

**相关规格**：[单池模型规格](../../openspec/specs/domain/pool/model.md)
**相关文档**：[系统设计](../architecture/system_design.md), [双层架构规格](../../openspec/specs/architecture/storage/dual_layer.md)
