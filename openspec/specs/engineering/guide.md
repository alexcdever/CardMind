# Spec Coding 实施指南

## 📋 文档编号: SP-GUIDE-005
**版本**: 1.0.0  
**最后更新**: 2026-01-14

---

## 1. 什么是 Spec Coding

### 1.1 核心理念

> **Spec Coding** = 测试即规格，规格即文档

Spec Coding 是一种**规格驱动的开发方法**，强调：

1. **测试是精确的行为规格** - 测试用例 = 可执行规格
2. **先定义行为，再实现代码** - 明确"应该做什么"
3. **规格可自动验证** - 通过测试保证实现符合规格
4. **知识沉淀** - 规格文档永远不会过时

### 1.2 与传统开发对比

| 维度 | 传统开发 | TDD | Spec Coding |
|-----|---------|-----|------------|
| **顺序** | 代码 → 测试 | 测试 → 代码 → 重构 | 规格 → 测试 → 代码 |
| **关注点** | 让代码工作 | 让测试通过 | **明确期望行为** |
| **文档** | 分离，易过期 | 无或分离 | **测试即文档** |
| **可执行性** | ❌ | ✅ | ✅✅（规格+测试） |

---

## 2. Spec Coding 工作流程

### 2.1 核心循环

```
┌─────────────────────────────────────────────┐
│  1. 编写规格文档                         │
│     - 数据结构定义                        │
│     - API 前置/后置条件                   │
│     - 测试用例（Given-When-Then）         │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────┐
│  2. 编写规格测试（可执行）               │
│     - it_should_xxx() 命名风格            │
│     - 清晰的 Given/When/Then 结构         │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────┐
│  3. 编写实现代码                          │
│     - 最小代码让测试通过                   │
│     - 遵循规格定义的约束                   │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────┐
│  4. 验证与文档                          │
│     - 运行测试                            │
│     - 生成 API 文档                       │
│     - 提交 PR                             │
└─────────────────────────────────────────────┘
```

---

## 3. 规格文档编写指南

### 3.1 文档结构

每个规格文档遵循统一结构：

```markdown
## 📋 规格编号: SP-XXX-XXX
**版本**: 1.0.0  
**状态**: 待实施/进行中/已完成  
**依赖**: 依赖的其他规格

## 1. 概述
目标、背景和动机

## 2. 数据模型规格
数据结构定义和约束

## 3. 方法规格
每个方法的：
- 前置条件
- 操作步骤
- 后置条件
- 测试用例（Spec-XXX 格式）

## 4. 集成规格
与其他模块的交互

## 5. 验证清单
测试覆盖检查清单
```

### 3.2 测试用例格式

#### Spec-XXX-A: 方法名称
```rust
/// 方法描述
/// 
/// # Arguments
/// * `param1` - 参数1描述
/// * `param2` - 参数2描述
/// 
/// # Behavior
/// - 前置条件
/// - 操作步骤
/// - 后置条件
pub fn method_name(...) -> Result<...> { ... }

#[test]
/// it_should_describe_what_happens()
#[test]
fn it_accepts_first_pool_join_when_device_is_uninitialized() {
    // Given: 设置初始条件
    let config = DeviceConfig::new();
    assert!(config.pool_id.is_none());
    
    // When: 执行操作
    config.join_pool("pool_A".to_string()).unwrap();
    
    // Then: 验证结果
    assert_eq!(config.pool_id, Some("pool_A".to_string()));
    
    // And: 验证副作用（如有）
    assert!(config_file_exists());
}
```

**命名规范**:
- ✅ 推荐: `it_should_xxx_when_yyy()`
- ✅ 可接受: `test_xxx()`
- ❌ 避免: `check_xxx()`, `verify_xxx()`

---

## 4. 实施检查清单

### 4.1 开始编码前

- [ ] 阅读相关规格文档
- [ ] 理解前置条件和约束
- [ ] 查看现有测试用例
- [ ] 运行业务示例理解流程

### 4.2 编码过程中

- [ ] 先写测试，再写实现
- [ ] 测试用例覆盖所有边界情况
- [ ] 遵循 Given-When-Then 结构
- [ ] 使用 `it_should_xxx` 命名风格

### 4.3 完成后

- [ ] 运行所有测试并确保通过
- [ ] 运行 `cargo clippy` 检查
- [ ] 生成 API 文档
- [ ] 更新规格文档状态

---

## 5. 工具和命令

### 5.1 查看规格

```bash
# 查看所有规格
ls -lh specs/domain/*.md specs/features/*/*.md

# 查看特定规格
cat specs/domain/pool_model.md

# 查看规格中心索引
cat specs/README.md
```

### 5.2 运行业务示例

```bash
# 运行单池模型流程示例
cd rust
cargo run --example single_pool_flow_spec

# 查看所有示例
ls rust/examples/
```

### 5.3 运行规格测试

```bash
# 运行所有 spec 风格的测试
cargo test it_should_ -- --nocapture

# 运行特定规格的测试
cargo test it_accepts_first_pool -- --nocapture

# 运行 Flutter 测试
flutter test test/specs/
```

### 5.4 代码质量检查

```bash
# 一键修复所有 lint 问题
dart tool/fix_lint.dart

# 检查但不修复
dart tool/check_lint.dart
```

---

## 6. 提交规范

### 6.1 PR 描述模板

```markdown
## 实现的规格

根据 `specs/domain/xxx.md` 或 `specs/features/xxx/yyy.md` 实施：

- ✅ Spec-XXX-A: 方法1描述
- ✅ Spec-XXX-B: 方法2描述
- ✅ Spec-XXX-C: 集成场景

## 测试覆盖

- 新增 X 个单元测试，全部通过
- 新增 Y 个集成测试，全部通过
- 测试覆盖率: XX%

## 文档更新

- [ ] 规格文档状态更新为"已完成"
- [ ] 生成新的 API 文档
- [ ] 更新 TODO.md
```

---

## 7. 常见问题

### Q1: 规格文档和代码注释有什么区别？

**A**: 
- **规格文档**描述"应该做什么"（What）
- **代码注释**描述"如何做的"（How）

### Q2: 如果规格和现有代码冲突怎么办？

**A**: 
1. 检查规格是否正确（可能需要更新）
2. 如果规格正确，按照规格修改代码
3. 添加测试验证新的行为

### Q3: 如何保证规格和代码同步？

**A**: 通过可执行规格（测试用例）自动验证。每次 PR 必须包含：
- 规格实现状态
- 对应的测试通过
- 如有变更，更新规格文档

---

## 8. 最佳实践

### 8.1 编写规格

- ✅ 明确前置条件和后置条件
- ✅ 考虑所有边界情况
- ✅ 提供具体的测试用例
- ❌ 避免模糊的描述

### 8.2 编写测试

- ✅ 使用 Given-When-Then 结构
- ✅ 测试名清晰描述场景
- ✅ 验证所有关键断言
- ❌ 避免过度复杂的 setup

### 8.3 代码实现

- ✅ 最小化实现（让测试通过即可）
- ✅ 遵循架构约束
- ✅ 使用正确的错误类型
- ❌ 避免添加未在规格中的功能

---

**规格编号**: SP-GUIDE-005  
**版本**: 1.0.0  
**最后更新**: 2026-01-14  
**状态**: 已发布
